<!DOCTYPE html>
<html lang="cs">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>IP Plan Validator v2</title>
    <script src="https://cdn.jsdelivr.net/npm/vue@3.4.15/dist/vue.global.prod.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
    <style>
        [v-cloak] { display: none; }

        * {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
        }

        .font-mono, .mono {
            font-family: 'JetBrains Mono', 'Consolas', monospace !important;
        }

        /* Hierarchical coloring - applied per cell, not per row */
        /* Colors defined as CSS variables for use in JavaScript */
        :root {
            --color-region: #C6EFCE;
            --color-segment: #A9D08E;
            --color-mg: #70AD47;
            --color-subscription: #92D050;
            --color-vnet: #FFC000;
            --color-subnet: #FFFFFF;
            --color-free-space: #E7E6E6;
        }

        /* Cell coloring classes */
        td.cell-region { background-color: #C6EFCE !important; }
        td.cell-segment { background-color: #A9D08E !important; }
        td.cell-mg { background-color: #70AD47 !important; color: white; }
        td.cell-subscription { background-color: #92D050 !important; }
        td.cell-vnet { background-color: #FFC000 !important; }
        td.cell-subnet { background-color: #FFFFFF !important; }
        td.cell-free-space { background-color: #E7E6E6 !important; color: #666; }
        td.cell-white { background-color: #FFFFFF !important; }

        /* Error states - higher priority */
        td.cell-error {
            background-color: #FFC7CE !important;
            color: #9C0006 !important;
        }
        tr.row-error {
            border-left: 5px solid #C00000 !important;
        }

        td.cell-warning {
            background-color: #FFEB9C !important;
            color: #9C5700 !important;
        }
        tr.row-warning {
            border-left: 5px solid #FF9900 !important;
        }

        /* Header styling - all blue */
        .header-calculated,
        .header-editable {
            background: linear-gradient(135deg, #3498DB 0%, #2980B9 100%) !important;
            color: white !important;
            font-weight: 600;
            text-shadow: 0 1px 2px rgba(0,0,0,0.2);
        }

        .row-hover:hover {
            filter: brightness(0.95);
            cursor: pointer;
        }
        .row-selected > td {
            box-shadow: inset 0 0 0 2px #2563eb !important;
        }

        /* Network Segment grouping borders - light green */
        td.seg-border-top { border-top: 3px solid #A9D08E !important; }
        td.seg-border-bottom { border-bottom: 3px solid #A9D08E !important; }
        td.seg-border-left { border-left: 3px solid #A9D08E !important; }
        td.seg-border-right { border-right: 3px solid #A9D08E !important; }

        /* Management Group borders - darker green */
        td.mg-border-top { border-top: 3px solid #70AD47 !important; }
        td.mg-border-bottom { border-bottom: 3px solid #70AD47 !important; }
        td.mg-border-left { border-left: 3px solid #70AD47 !important; }
        td.mg-border-right { border-right: 3px solid #70AD47 !important; }

        /* Subscription grouping borders - yellow-green */
        td.sub-border-top { border-top: 3px solid #92D050 !important; }
        td.sub-border-bottom { border-bottom: 3px solid #92D050 !important; }
        td.sub-border-left { border-left: 3px solid #92D050 !important; }
        td.sub-border-right { border-right: 3px solid #92D050 !important; }

        /* VNet grouping borders - yellow/orange */
        td.vnet-border-top { border-top: 3px solid #FFC000 !important; }
        td.vnet-border-bottom { border-bottom: 3px solid #FFC000 !important; }
        td.vnet-border-left { border-left: 3px solid #FFC000 !important; }
        td.vnet-border-right { border-right: 3px solid #FFC000 !important; }

        table {
            border-collapse: collapse;
            width: 100%;
            font-size: 11px;
        }
        thead {
            box-shadow: 0 1px 2px rgba(0,0,0,0.1);
        }
        tbody tr {
            border: 1px solid #E0E0E0;
        }
        th {
            border: 1px solid rgba(255,255,255,0.2);
            padding: 6px 6px !important;
            white-space: nowrap;
            font-size: 10px;
            text-transform: uppercase;
            letter-spacing: 0.3px;
        }
        td {
            border-right: 1px solid #E8E8E8;
            padding: 3px 6px !important;
        }

        /* Editable cell styling */
        .editable-cell {
            cursor: text;
            min-width: 40px;
        }
        .editable-cell:hover {
            background-color: rgba(52, 152, 219, 0.15) !important;
            cursor: pointer;
        }
        .editing-cell {
            padding: 0 !important;
            background-color: #EBF5FB !important;
        }
        .edit-input {
            width: 100%;
            padding: 3px 6px;
            border: 2px solid #3498DB !important;
            outline: none;
            font-size: inherit;
            font-family: inherit;
            background: white !important;
            box-sizing: border-box;
        }
        .edit-input:focus {
            background: #FFF9C4 !important;
        }

        /* Stats cards - compact */
        .stat-card {
            background: white;
            border-radius: 8px;
            padding: 8px 12px;
            box-shadow: 0 1px 4px rgba(0,0,0,0.06);
            border: 1px solid #E8E8E8;
        }
        .stat-card.error { border-left: 3px solid #E74C3C; }
        .stat-card.warning { border-left: 3px solid #F39C12; }
        .stat-card.info { border-left: 3px solid #3498DB; }
        .stat-card.success { border-left: 3px solid #27AE60; }

        /* Buttons */
        .btn {
            padding: 6px 12px;
            border-radius: 5px;
            font-weight: 500;
            font-size: 11px;
            border: none;
            cursor: pointer;
            display: inline-flex;
            align-items: center;
            gap: 4px;
        }
        .btn:hover { opacity: 0.9; }
        .btn-primary { background: #3498DB; color: white; }
        .btn-success { background: #27AE60; color: white; }
        .btn-purple { background: #9B59B6; color: white; }
        .btn-indigo { background: #5C6BC0; color: white; }
        .btn-orange { background: #E67E22; color: white; }
        .btn-gray { background: #7F8C8D; color: white; }
        .btn-danger { background: #E74C3C; color: white; }
        .btn:disabled { opacity: 0.5; cursor: not-allowed; }

        /* Action buttons in table */
        .action-btn {
            width: 18px;
            height: 18px;
            border-radius: 3px;
            border: none;
            cursor: pointer;
            font-size: 10px;
            font-weight: 600;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            margin: 0 1px;
        }
        .action-btn:hover { opacity: 0.8; }
        .action-btn.add { background: #E3F2FD; color: #1976D2; }
        .action-btn.dup { background: #E8F5E9; color: #388E3C; }
        .action-btn.del { background: #FFEBEE; color: #D32F2F; }
        .action-btn.up { background: #FFF3E0; color: #E65100; }
        .action-btn.down { background: #FFF3E0; color: #E65100; }
        .action-btn:disabled { opacity: 0.3; cursor: not-allowed; }

        /* Legend - compact inline */
        .legend-item {
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 10px;
            font-weight: 500;
            border: 1px solid rgba(0,0,0,0.1);
        }

        /* Side panel */
        .side-panel {
            position: fixed;
            right: 0;
            top: 0;
            width: 320px;
            height: 100vh;
            background: white;
            box-shadow: -4px 0 20px rgba(0,0,0,0.1);
            z-index: 40;
            overflow-y: auto;
            padding: 16px;
            transform: translateX(100%);
            transition: transform 0.3s ease;
        }
        .side-panel.open {
            transform: translateX(0);
        }
        .side-panel-toggle {
            position: fixed;
            right: 0;
            top: 50%;
            transform: translateY(-50%);
            background: white;
            border: 1px solid #ddd;
            border-right: none;
            border-radius: 8px 0 0 8px;
            padding: 12px 8px;
            cursor: pointer;
            z-index: 41;
            box-shadow: -2px 0 8px rgba(0,0,0,0.1);
            writing-mode: vertical-rl;
            font-size: 12px;
            font-weight: 600;
        }
        .side-panel-toggle:hover {
            background: #f5f5f5;
        }
        .side-panel-toggle.has-errors {
            background: #FFC7CE;
            color: #9C0006;
        }
        .side-panel.open + .side-panel-toggle {
            right: 320px;
        }

        /* Panels - compact */
        .panel {
            border-radius: 8px;
            padding: 10px;
            margin-bottom: 10px;
        }
        .panel-error {
            background: #FFF5F5;
            border: 1px solid #FED7D7;
        }
        .panel-warning {
            background: #FFFBEB;
            border: 1px solid #FEF3C7;
        }
        .panel-info {
            background: #EFF6FF;
            border: 1px solid #DBEAFE;
        }

        /* Scrollbar */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }
        ::-webkit-scrollbar-track {
            background: #F1F1F1;
            border-radius: 4px;
        }
        ::-webkit-scrollbar-thumb {
            background: #C1C1C1;
            border-radius: 4px;
        }
        ::-webkit-scrollbar-thumb:hover {
            background: #A1A1A1;
        }

        /* Table container */
        .table-container {
            background: white;
            border-radius: 6px;
            box-shadow: 0 1px 4px rgba(0,0,0,0.06);
            overflow: hidden;
        }
        .table-scroll {
            overflow-x: auto;
            max-height: calc(100vh - 130px);
            overflow-y: auto;
        }

        /* Main content with side panel */
        .main-content {
            transition: margin-right 0.3s ease;
        }
        .main-content.panel-open {
            margin-right: 330px;
        }

        /* Modal */
        .modal-overlay {
            background: rgba(0, 0, 0, 0.5);
        }
        .modal-content {
            background: white;
            border-radius: 10px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
        }
    </style>
</head>
<body class="bg-gray-50">
    <div id="app" v-cloak class="p-3 max-w-full">
        <div class="flex items-center justify-between mb-3" v-if="!csvData.length">
            <h1 class="text-2xl font-bold text-gray-800">IP Plan Validator</h1>
        </div>

        <!-- File Upload / New Plan -->
        <div v-if="!csvData.length" class="mb-4">
            <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                <!-- Upload existing file -->
                <div class="border-2 border-dashed border-gray-300 rounded-lg p-8 text-center bg-white hover:border-blue-400 hover:bg-blue-50 transition-all cursor-pointer"
                     @dragover.prevent="dragOver = true"
                     @dragleave.prevent="dragOver = false"
                     @drop.prevent="handleFileDrop"
                     :class="{ 'border-blue-500 bg-blue-50': dragOver }">
                    <svg class="w-12 h-12 mx-auto mb-3 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12"/>
                    </svg>
                    <p class="text-lg font-medium text-gray-700 mb-2">Nacist existujici plan</p>
                    <p class="text-sm text-gray-500 mb-3">Pretahni CSV soubor sem nebo</p>
                    <label class="cursor-pointer">
                        <span class="btn btn-primary px-6 py-2">Vyber soubor</span>
                        <input type="file" accept=".csv" @change="handleFileSelect" class="hidden">
                    </label>
                    <p class="text-xs text-gray-400 mt-3">Format: CSV s oddelovacem strednik (;)</p>
                </div>

                <!-- Create new plan -->
                <div class="border-2 border-dashed border-green-300 rounded-lg p-8 text-center bg-white hover:border-green-400 hover:bg-green-50 transition-all cursor-pointer"
                     @click="createNewPlan">
                    <svg class="w-12 h-12 mx-auto mb-3 text-green-500" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 6v6m0 0v6m0-6h6m-6 0H6"/>
                    </svg>
                    <p class="text-lg font-medium text-gray-700 mb-2">Vytvorit novy plan</p>
                    <p class="text-sm text-gray-500 mb-3">Zacni s prazdnou tabulkou</p>
                    <span class="btn btn-success px-6 py-2">Novy IP plan</span>
                    <p class="text-xs text-gray-400 mt-3">Vytvoris novou strukturu od zacatku</p>
                </div>
            </div>
        </div>

        <!-- Main Content -->
        <div v-if="csvData.length" class="main-content" :class="{ 'panel-open': sidePanelOpen }">
            <!-- Compact toolbar -->
            <div class="flex items-center justify-between gap-4 mb-3 flex-wrap">
                <!-- Stats inline -->
                <div class="flex items-center gap-3 text-sm">
                    <span class="text-gray-600">Radku: <strong>{{ csvData.length }}</strong></span>
                    <span class="text-gray-400">|</span>
                    <span class="text-green-600">Subnety: <strong>{{ totalSubnets }}</strong></span>
                    <span class="text-gray-400">|</span>
                    <span class="text-gray-500">Free: <strong>{{ totalFreeSpace }}</strong></span>
                    <span class="text-gray-400">|</span>
                    <span class="text-red-600 cursor-pointer hover:underline" @click="sidePanelOpen = true" v-if="errorRows.size">Chyby: <strong>{{ errorRows.size }}</strong></span>
                    <span class="text-green-600" v-else>Chyby: <strong>0</strong></span>
                    <span class="text-gray-400">|</span>
                    <span class="text-yellow-600 cursor-pointer hover:underline" @click="sidePanelOpen = true" v-if="warnings.length">Varovani: <strong>{{ warnings.length }}</strong></span>
                    <span class="text-gray-500" v-else>Varovani: <strong>0</strong></span>
                    <span class="text-gray-400">|</span>
                    <span class="text-blue-600 cursor-pointer hover:underline" @click="sidePanelOpen = true" v-if="gaps.length">Free space: <strong>{{ gaps.length }}</strong></span>
                    <span class="text-gray-500" v-else>Free space: <strong>0</strong></span>
                </div>

                <!-- Legend inline -->
                <div class="flex items-center gap-1 flex-wrap">
                    <span class="legend-item" style="background-color: #C6EFCE;">Reg</span>
                    <span class="legend-item" style="background-color: #A9D08E;">Seg</span>
                    <span class="legend-item" style="background-color: #70AD47; color: white;">MG</span>
                    <span class="legend-item" style="background-color: #92D050;">Sub</span>
                    <span class="legend-item" style="background-color: #FFC000;">VNet</span>
                    <span class="legend-item" style="background-color: #FFFFFF;">Subnet</span>
                    <span class="legend-item" style="background-color: #E7E6E6;">Free</span>
                    <span class="legend-item" style="background-color: #FFC7CE; color: #9C0006;">Err</span>
                </div>
            </div>

            <!-- Actions -->
            <div class="mb-2 flex flex-wrap gap-2">
                <button @click="validateAll" class="btn btn-primary text-xs px-3 py-2">Validovat</button>
                <button @click="detectGaps" class="btn btn-success text-xs px-3 py-2">Free space helper</button>
                <button @click="fillAllGaps" class="btn btn-purple text-xs px-3 py-2" :disabled="!gaps.length">Doplnit ({{ gaps.length }})</button>
                <button @click="sortByIP" class="btn btn-orange text-xs px-3 py-2">Seradit dle IP</button>
                <button @click="recalculateAll" class="btn btn-indigo text-xs px-3 py-2">Prepocitat</button>
                <button @click="exportCSV" class="btn btn-gray text-xs px-3 py-2">Export</button>
                <button @click="reset" class="btn btn-danger text-xs px-3 py-2">Novy soubor</button>
                <button @click="sidePanelOpen = !sidePanelOpen" class="btn text-xs px-3 py-2" :class="hasIssues ? 'btn-danger' : 'btn-gray'">
                    {{ sidePanelOpen ? 'Skryt' : 'Zobrazit' }} panel ({{ errorRows.size + warnings.length + gaps.length }})
                </button>
            </div>

            <!-- Data Table -->
            <div class="table-container">
                <div class="table-scroll">
                    <table class="min-w-full">
                    <thead class="sticky top-0 z-10">
                        <tr>
                            <th class="px-2 py-2 text-left header-editable">#</th>
                            <th class="px-2 py-2 text-left header-editable">Region</th>
                            <th class="px-2 py-2 text-left header-editable">Network Segment</th>
                            <th class="px-2 py-2 text-left header-editable">MG</th>
                            <th class="px-2 py-2 text-left header-editable">Subscription</th>
                            <th class="px-2 py-2 text-left header-editable">VNet</th>
                            <th class="px-2 py-2 text-left header-editable">Type</th>
                            <th class="px-2 py-2 text-left header-calculated">Start</th>
                            <th class="px-2 py-2 text-left header-calculated">Address Space</th>
                            <th class="px-2 py-2 text-left header-editable">Purpose</th>
                            <th class="px-2 py-2 text-left header-calculated">Name</th>
                            <th class="px-2 py-2 text-left header-calculated">Avail</th>
                            <th class="px-2 py-2 text-left header-editable">Comments</th>
                            <th class="px-2 py-2 text-left header-editable">Akce</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr v-for="(row, index) in csvData"
                            :key="index"
                            :id="'row-' + (index + 2)"
                            :class="[getRowClass(row, index), 'border-t row-hover', selectedRowIndex === index ? 'row-selected' : '']"
                            @click="selectRow(index)">
                            <td class="px-2 py-2 text-gray-500 bg-white">{{ index + 2 }}</td>

                            <!-- Region - editable (colIndex 0) -->
                            <td class="px-2 py-2 editable-cell" :class="[getCellClass(row, 0, index), getCellBorderClass(row, 0, index), {'editing-cell': isEditing(index, 'Region')}]" @dblclick.stop="startEdit(index, 'Region', $event)">
                                <input v-if="isEditing(index, 'Region')"
                                       v-model="row.Region"
                                       @blur="stopEdit"
                                       @keyup.enter="stopEdit"
                                       @keyup.escape="cancelEdit"
                                       class="w-full edit-input">
                                <span v-else>{{ row.Region }}</span>
                            </td>

                            <!-- Network segment - editable (colIndex 1) -->
                            <td class="px-2 py-2 editable-cell" :class="[getCellClass(row, 1, index), getCellBorderClass(row, 1, index), {'editing-cell': isEditing(index, 'Network segment')}]" @dblclick.stop="startEdit(index, 'Network segment', $event)">
                                <input v-if="isEditing(index, 'Network segment')"
                                       v-model="row['Network segment']"
                                       @blur="stopEdit"
                                       @keyup.enter="stopEdit"
                                       @keyup.escape="cancelEdit"
                                       class="edit-input">
                                <span v-else>{{ row['Network segment'] }}</span>
                            </td>

                            <!-- Management Group - editable (colIndex 2) -->
                            <td class="px-2 py-2 editable-cell" :class="[getCellClass(row, 2, index), getCellBorderClass(row, 2, index), {'editing-cell': isEditing(index, 'Management Group')}]" @dblclick.stop="startEdit(index, 'Management Group', $event)">
                                <input v-if="isEditing(index, 'Management Group')"
                                       v-model="row['Management Group']"
                                       @blur="stopEdit"
                                       @keyup.enter="stopEdit"
                                       @keyup.escape="cancelEdit"
                                       class="edit-input">
                                <span v-else>{{ row['Management Group'] }}</span>
                            </td>

                            <!-- Subscription - editable (colIndex 3) -->
                            <td class="px-2 py-2 font-medium editable-cell" :class="[getCellClass(row, 3, index), getCellBorderClass(row, 3, index), {'editing-cell': isEditing(index, 'Subscription')}]" @dblclick.stop="startEdit(index, 'Subscription', $event)">
                                <input v-if="isEditing(index, 'Subscription')"
                                       v-model="row.Subscription"
                                       @blur="stopEdit"
                                       @keyup.enter="stopEdit"
                                       @keyup.escape="cancelEdit"
                                       class="edit-input">
                                <span v-else>{{ row.Subscription }}</span>
                            </td>

                            <!-- VNet name - editable (colIndex 4) -->
                            <td class="px-2 py-2 font-medium editable-cell" :class="[getCellClass(row, 4, index), getCellBorderClass(row, 4, index), {'editing-cell': isEditing(index, 'VNet name')}]" @dblclick.stop="startEdit(index, 'VNet name', $event)">
                                <input v-if="isEditing(index, 'VNet name')"
                                       v-model="row['VNet name']"
                                       @blur="stopEdit"
                                       @keyup.enter="stopEdit"
                                       @keyup.escape="cancelEdit"
                                       class="edit-input">
                                <span v-else>{{ row['VNet name'] }}</span>
                            </td>

                            <!-- Subnet type - editable (colIndex 5) -->
                            <td class="px-2 py-2 editable-cell" :class="[getCellClass(row, 5, index), getCellBorderClass(row, 5, index), {'editing-cell': isEditing(index, 'Subnet type')}]" @dblclick.stop="startEdit(index, 'Subnet type', $event)">
                                <select v-if="isEditing(index, 'Subnet type')"
                                        v-model="row['Subnet type']"
                                        @blur="stopEdit"
                                        @change="stopEdit"
                                        class="edit-input">
                                    <option value="">-</option>
                                    <option value="isolated">isolated</option>
                                    <option value="common">common</option>
                                </select>
                                <span v-else>{{ row['Subnet type'] }}</span>
                            </td>

                            <!-- Start - editable (colIndex 6) -->
                            <td class="px-2 py-2 font-mono text-blue-700 editable-cell" :class="[getCellClass(row, 6, index), getCellBorderClass(row, 6, index), {'editing-cell': isEditing(index, 'Start')}]" @dblclick.stop="startEdit(index, 'Start', $event)">
                                <input v-if="isEditing(index, 'Start')"
                                       v-model="row.Start"
                                       @blur="onStartEdit(index)"
                                       @keyup.enter="onStartEdit(index)"
                                       @keyup.escape="cancelEdit"
                                       class="font-mono edit-input">
                                <span v-else>{{ row.Start }}</span>
                            </td>

                            <!-- Address space (colIndex 7) -->
                            <td class="px-2 py-2 font-mono text-xs text-green-700" :class="[getCellClass(row, 7, index), getCellBorderClass(row, 7, index)]">{{ row['Address space'] }}</td>

                            <!-- Subnet purpose - editable (colIndex 8) -->
                            <td class="px-2 py-2 editable-cell" :class="[getCellClass(row, 8, index), getCellBorderClass(row, 8, index), {'editing-cell': isEditing(index, 'Subnet purpose')}]" @dblclick.stop="startEdit(index, 'Subnet purpose', $event)">
                                <input v-if="isEditing(index, 'Subnet purpose')"
                                       v-model="row['Subnet purpose']"
                                       @blur="onPurposeEdit(index)"
                                       @keyup.enter="onPurposeEdit(index)"
                                       @keyup.escape="cancelEdit"
                                       class="edit-input">
                                <span v-else>{{ row['Subnet purpose'] }}</span>
                            </td>

                            <!-- Subnet name (colIndex 9) -->
                            <td class="px-2 py-2 font-mono text-xs" :class="[getCellClass(row, 9, index), getCellBorderClass(row, 9, index)]">{{ row['Subnet name'] }}</td>

                            <!-- Available addresses (colIndex 10) -->
                            <td class="px-2 py-2 text-right" :class="[getCellClass(row, 10, index), getCellBorderClass(row, 10, index)]">{{ row['Available addresses'] }}</td>

                            <!-- Comments - editable (colIndex 11) -->
                            <td class="px-2 py-2 text-gray-600 italic text-xs editable-cell" :class="[getCellClass(row, 11, index), getCellBorderClass(row, 11, index), {'editing-cell': isEditing(index, 'Comments')}]" @dblclick.stop="startEdit(index, 'Comments', $event)">
                                <input v-if="isEditing(index, 'Comments')"
                                       v-model="row.Comments"
                                       @blur="stopEdit"
                                       @keyup.enter="stopEdit"
                                       @keyup.escape="cancelEdit"
                                       class="edit-input">
                                <span v-else>{{ row.Comments }}</span>
                            </td>

                            <!-- Actions (colIndex 12) -->
                            <td class="px-2 py-2 whitespace-nowrap text-center bg-white" :class="getCellBorderClass(row, 12, index)">
                                <button @click.stop="moveRowUp(index)" class="action-btn up" title="Presunout nahoru" :disabled="index === 0">&#9650;</button>
                                <button @click.stop="moveRowDown(index)" class="action-btn down" title="Presunout dolu" :disabled="index === csvData.length - 1">&#9660;</button>
                                <button @click.stop="addSubnetAfter(index)" class="action-btn add" title="Pridat radek za">+</button>
                                <button @click.stop="duplicateRow(index)" class="action-btn dup" title="Duplikovat">D</button>
                                <button @click.stop="deleteRow(index)" class="action-btn del" title="Smazat">X</button>
                            </td>
                        </tr>
                    </tbody>
                </table>
                </div>
            </div>

            <!-- Edit hint -->
            <div class="mt-2 text-center text-xs text-gray-400">
                Dvojklik = editace | Enter = potvrdit | Escape = zrusit
            </div>
        </div>

        <!-- Side Panel for Errors/Warnings/Gaps -->
        <div class="side-panel" :class="{ 'open': sidePanelOpen }" v-if="csvData.length">
            <div class="flex items-center justify-between mb-4">
                <h3 class="font-bold text-gray-800">Problemy & Free space</h3>
                <button @click="sidePanelOpen = false" class="text-gray-400 hover:text-gray-600 text-xl">&times;</button>
            </div>

            <!-- Errors -->
            <div v-if="errors.length" class="panel panel-error mb-3">
                <h4 class="font-semibold text-red-700 text-sm mb-2">Chyby ({{ errorRows.size }} radku)</h4>
                <ul class="space-y-1 text-xs max-h-32 overflow-y-auto">
                    <li v-for="(error, index) in errors" :key="index"
                        class="text-red-600 cursor-pointer hover:bg-red-100 px-2 py-1 rounded"
                        @click="scrollToRow(error.row)">
                        <span v-if="error.row2" class="inline-flex gap-1">
                            <span @click.stop="scrollToRow(error.row)" class="underline hover:text-red-800">#{{ error.row }}</span>
                            <span>&amp;</span>
                            <span @click.stop="scrollToRow(error.row2)" class="underline hover:text-red-800">#{{ error.row2 }}</span>
                            <span>se prekryvaji</span>
                        </span>
                        <span v-else><strong>#{{ error.row }}:</strong> {{ error.message }}</span>
                    </li>
                </ul>
            </div>

            <!-- Warnings -->
            <div v-if="warnings.length" class="panel panel-warning mb-3">
                <h4 class="font-semibold text-yellow-700 text-sm mb-2">Varovani ({{ warnings.length }})</h4>
                <ul class="space-y-1 text-xs max-h-32 overflow-y-auto">
                    <li v-for="(warning, index) in warnings" :key="index"
                        class="text-yellow-600 cursor-pointer hover:bg-yellow-100 px-2 py-1 rounded"
                        @click="scrollToRow(warning.row); sidePanelOpen = false">
                        <strong>{{ warning.row }}:</strong> {{ warning.message }}
                    </li>
                </ul>
            </div>

            <!-- Gaps -->
            <div v-if="gaps.length" class="panel panel-info">
                <div class="flex items-center justify-between mb-2">
                    <h4 class="font-semibold text-blue-700 text-sm">Free space ({{ gaps.length }})</h4>
                    <button @click="fillAllGaps" class="text-xs text-blue-600 hover:underline">Doplnit vse</button>
                </div>
                <div class="space-y-2 max-h-64 overflow-y-auto">
                    <div v-for="(gap, index) in gaps" :key="index" class="bg-white p-2 rounded border text-xs">
                        <div class="font-mono text-blue-700">{{ gap.start }} - {{ gap.end }}</div>
                        <div class="text-gray-500">{{ formatNumber(gap.size) }} adres | {{ gap.scopeLabel }} | radek {{ gap.afterRow }}</div>
                        <button @click="fillGap(gap)" class="mt-1 text-blue-600 hover:underline text-xs">Doplnit</button>
                    </div>
                </div>
            </div>

            <!-- No issues -->
            <div v-if="!errors.length && !warnings.length && !gaps.length" class="text-center py-8 text-gray-400">
                <svg class="w-12 h-12 mx-auto mb-2 text-green-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z"/>
                </svg>
                <p>Zadne problemy!</p>
            </div>
        </div>

        <!-- Add Subnet Modal -->
        <div v-if="showAddModal" class="fixed inset-0 modal-overlay flex items-center justify-center z-50" @click.self="showAddModal = false">
            <div class="modal-content p-5 max-w-xl w-full mx-4 max-h-[85vh] overflow-y-auto">
                <div class="flex items-center justify-between mb-4">
                    <h2 class="text-lg font-bold text-gray-800">Pridat radek za #{{ selectedRowIndex + 2 }}</h2>
                    <button @click="showAddModal = false" class="text-gray-400 hover:text-gray-600 text-xl">&times;</button>
                </div>

                <div class="grid grid-cols-2 gap-3 mb-3">
                    <div>
                        <label class="block text-xs font-medium text-gray-600 mb-1">Rozsah</label>
                        <input v-model="newSubnet.suggested" class="w-full p-2 border rounded font-mono text-sm" @input="updateNewSubnetFromSuggested" placeholder="10.0.0.0/24">
                    </div>
                    <div>
                        <label class="block text-xs font-medium text-gray-600 mb-1">Prefix</label>
                        <select v-model="newSubnet.prefix" @change="updateNewSubnet" class="w-full p-2 border rounded text-sm">
                            <option v-for="p in availablePrefixes" :key="p" :value="p">/{{ p }} ({{ formatNumber(calculateAvailableIPs(p)) }})</option>
                        </select>
                    </div>
                </div>

                <div class="grid grid-cols-2 gap-3 mb-3">
                    <div>
                        <label class="block text-xs font-medium text-gray-600 mb-1">Start</label>
                        <input v-model="newSubnet.start" readonly class="w-full p-2 border rounded bg-gray-50 font-mono text-sm text-gray-500">
                    </div>
                    <div>
                        <label class="block text-xs font-medium text-gray-600 mb-1">Address Space</label>
                        <input v-model="newSubnet.addressSpace" readonly class="w-full p-2 border rounded bg-gray-50 font-mono text-xs text-gray-500">
                    </div>
                </div>

                <div class="grid grid-cols-3 gap-3 mb-3">
                    <div>
                        <label class="block text-xs font-medium text-gray-600 mb-1">Type</label>
                        <select v-model="newSubnet.type" class="w-full p-2 border rounded text-sm">
                            <option value="">-</option>
                            <option value="isolated">isolated</option>
                            <option value="common">common</option>
                        </select>
                    </div>
                    <div>
                        <label class="block text-xs font-medium text-gray-600 mb-1">Purpose</label>
                        <input v-model="newSubnet.purpose" @input="updateSubnetName" class="w-full p-2 border rounded text-sm" placeholder="web, db...">
                    </div>
                    <div>
                        <label class="block text-xs font-medium text-gray-600 mb-1">Comments</label>
                        <input v-model="newSubnet.comments" class="w-full p-2 border rounded text-sm" placeholder="...">
                    </div>
                </div>

                <div class="grid grid-cols-2 gap-3 mb-4">
                    <div>
                        <label class="block text-xs font-medium text-gray-600 mb-1">Name (auto)</label>
                        <input v-model="newSubnet.name" readonly class="w-full p-2 border rounded bg-gray-50 font-mono text-xs text-gray-500">
                    </div>
                    <div>
                        <label class="block text-xs font-medium text-gray-600 mb-1">Avail IPs</label>
                        <input v-model="newSubnet.available" readonly class="w-full p-2 border rounded bg-gray-50 text-sm text-gray-500">
                    </div>
                </div>

                <div class="flex justify-end gap-2 pt-3 border-t">
                    <button @click="showAddModal = false" class="btn btn-gray">Zrusit</button>
                    <button @click="confirmAddSubnet" class="btn btn-primary">Pridat</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        const { createApp, nextTick } = Vue;

        createApp({
            data() {
                return {
                    csvData: [],
                    errors: [],
                    warnings: [],
                    gaps: [],
                    errorRows: new Set(),
                    warningRows: new Set(),
                    showAddModal: false,
                    selectedRowIndex: -1,
                    editingCell: null,
                    editOriginalValue: '',
                    dragOver: false,
                    lastValidation: '',
                    sidePanelOpen: false,
                    newSubnet: {
                        suggested: '',
                        prefix: 24,
                        start: '',
                        addressSpace: '',
                        type: '',
                        purpose: '',
                        name: '',
                        available: '',
                        comments: ''
                    },
                    availablePrefixes: [16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30],
                    segmentGroups: [],
                    mgGroups: [],
                    subscriptionGroups: [],
                    vnetGroups: []
                }
            },
            computed: {
                totalSubnets() {
                    return this.csvData.filter(row => this.getRowLevel(row) === 'subnet').length;
                },
                totalFreeSpace() {
                    return this.csvData.filter(row => this.getRowLevel(row) === 'free-space').length;
                },
                hasIssues() {
                    return this.errorRows.size > 0 || this.warnings.length > 0 || this.gaps.length > 0;
                }
            },
            methods: {
                handleFileDrop(e) {
                    this.dragOver = false;
                    const file = e.dataTransfer.files[0];
                    this.loadFile(file);
                },
                handleFileSelect(e) {
                    const file = e.target.files[0];
                    this.loadFile(file);
                },
                loadFile(file) {
                    if (!file || !file.name.endsWith('.csv')) {
                        alert('Prosim vyberte CSV soubor');
                        return;
                    }

                    const reader = new FileReader();
                    reader.onload = (e) => {
                        this.parseCSV(e.target.result);
                        this.validateAll();
                        this.detectGaps();
                    };
                    reader.readAsText(file, 'UTF-8');
                },
                parseCSV(text) {
                    const lines = text.split('\n');
                    const headers = lines[0].split(';').map(h => h.trim().replace(/^\uFEFF/, ''));

                    this.csvData = [];
                    for (let i = 1; i < lines.length; i++) {
                        if (!lines[i].trim()) continue;

                        const values = lines[i].split(';');
                        const row = {};
                        headers.forEach((header, idx) => {
                            row[header] = values[idx] ? values[idx].trim() : '';
                        });
                        this.csvData.push(row);
                    }

                    this.calculateGroups();
                },
                calculateGroups() {
                    this.segmentGroups = [];
                    this.mgGroups = [];
                    this.subscriptionGroups = [];
                    this.vnetGroups = [];

                    // Find Network Segment groups based on IP ranges
                    let i = 0;
                    while (i < this.csvData.length) {
                        const row = this.csvData[i];
                        const segment = row['Network segment'] && row['Network segment'].trim();
                        const segStart = row.Start;
                        const level = this.getRowLevel(row);

                        if (segment && segStart && segStart.includes('/') && level === 'network-segment') {
                            try {
                                const segNet = this.parseNetwork(segStart);
                                const groupStart = i;
                                let groupEnd = i;

                                for (let j = i + 1; j < this.csvData.length; j++) {
                                    const nextRow = this.csvData[j];
                                    const nextStart = nextRow.Start;
                                    const nextLevel = this.getRowLevel(nextRow);

                                    if (nextLevel === 'network-segment' || nextLevel === 'region') {
                                        break;
                                    }

                                    if (nextStart && nextStart.includes('/')) {
                                        try {
                                            const nextNet = this.parseNetwork(nextStart);
                                            if (nextNet.numericStart >= segNet.numericStart &&
                                                nextNet.numericEnd <= segNet.numericEnd) {
                                                groupEnd = j;
                                            } else {
                                                break;
                                            }
                                        } catch (e) {}
                                    }
                                }

                                this.segmentGroups.push({
                                    start: groupStart,
                                    end: groupEnd,
                                    name: segment,
                                    range: segNet
                                });

                                i = groupEnd + 1;
                                continue;
                            } catch (e) {}
                        }
                        i++;
                    }

                    // Find Management Group groups based on IP ranges
                    i = 0;
                    while (i < this.csvData.length) {
                        const row = this.csvData[i];
                        const mg = row['Management Group'] && row['Management Group'].trim();
                        const mgStart = row.Start;
                        const level = this.getRowLevel(row);

                        if (mg && mgStart && mgStart.includes('/') && level === 'management-group') {
                            try {
                                const mgNet = this.parseNetwork(mgStart);
                                const groupStart = i;
                                let groupEnd = i;

                                for (let j = i + 1; j < this.csvData.length; j++) {
                                    const nextRow = this.csvData[j];
                                    const nextStart = nextRow.Start;
                                    const nextLevel = this.getRowLevel(nextRow);

                                    if (nextLevel === 'management-group' || nextLevel === 'network-segment' || nextLevel === 'region') {
                                        break;
                                    }

                                    if (nextStart && nextStart.includes('/')) {
                                        try {
                                            const nextNet = this.parseNetwork(nextStart);
                                            if (nextNet.numericStart >= mgNet.numericStart &&
                                                nextNet.numericEnd <= mgNet.numericEnd) {
                                                groupEnd = j;
                                            } else {
                                                break;
                                            }
                                        } catch (e) {}
                                    }
                                }

                                this.mgGroups.push({
                                    start: groupStart,
                                    end: groupEnd,
                                    name: mg,
                                    range: mgNet
                                });

                                i = groupEnd + 1;
                                continue;
                            } catch (e) {}
                        }
                        i++;
                    }

                    // Find VNet groups based on IP ranges
                    i = 0;
                    while (i < this.csvData.length) {
                        const row = this.csvData[i];
                        const vnet = row['VNet name'] && row['VNet name'].trim();
                        const vnetStart = row.Start;

                        if (vnet && vnetStart && vnetStart.includes('/')) {
                            // Found a VNet with IP range
                            try {
                                const vnetNet = this.parseNetwork(vnetStart);
                                const groupStart = i;
                                let groupEnd = i;

                                // Find all following rows that fall within this VNet's IP range
                                for (let j = i + 1; j < this.csvData.length; j++) {
                                    const nextRow = this.csvData[j];
                                    const nextVnet = nextRow['VNet name'] && nextRow['VNet name'].trim();
                                    const nextStart = nextRow.Start;

                                    // Stop if we hit another VNet definition
                                    if (nextVnet) break;

                                    // Check if this row's IP falls within VNet range
                                    if (nextStart && nextStart.includes('/')) {
                                        try {
                                            const nextNet = this.parseNetwork(nextStart);
                                            // Check if subnet is within VNet range
                                            if (nextNet.numericStart >= vnetNet.numericStart &&
                                                nextNet.numericEnd <= vnetNet.numericEnd) {
                                                groupEnd = j;
                                            } else {
                                                // IP is outside VNet range, stop
                                                break;
                                            }
                                        } catch (e) {
                                            // Invalid IP, skip
                                        }
                                    } else {
                                        // Row without IP, check if it's a higher level
                                        const level = this.getRowLevel(nextRow);
                                        if (level === 'subscription' || level === 'management-group' ||
                                            level === 'network-segment' || level === 'region') {
                                            break;
                                        }
                                    }
                                }

                                this.vnetGroups.push({
                                    start: groupStart,
                                    end: groupEnd,
                                    name: vnet,
                                    range: vnetNet
                                });

                                i = groupEnd + 1;
                                continue;
                            } catch (e) {
                                // Invalid VNet IP, skip
                            }
                        }
                        i++;
                    }

                    // Find Subscription groups based on IP ranges
                    i = 0;
                    while (i < this.csvData.length) {
                        const row = this.csvData[i];
                        const subscription = row.Subscription && row.Subscription.trim();
                        const subStart = row.Start;
                        const level = this.getRowLevel(row);

                        // Create subscription group for subscription-level rows
                        if (subscription && subStart && subStart.includes('/') && level === 'subscription') {
                            try {
                                const subNet = this.parseNetwork(subStart);
                                const groupStart = i;
                                let groupEnd = i;

                                // Find all following rows that fall within this Subscription's IP range
                                for (let j = i + 1; j < this.csvData.length; j++) {
                                    const nextRow = this.csvData[j];
                                    const nextStart = nextRow.Start;
                                    const nextLevel = this.getRowLevel(nextRow);

                                    // Stop if we hit another Subscription definition or higher level
                                    if (nextLevel === 'subscription' || nextLevel === 'management-group' ||
                                        nextLevel === 'network-segment' || nextLevel === 'region') {
                                        break;
                                    }

                                    // Check if this row's IP falls within Subscription range
                                    if (nextStart && nextStart.includes('/')) {
                                        try {
                                            const nextNet = this.parseNetwork(nextStart);
                                            if (nextNet.numericStart >= subNet.numericStart &&
                                                nextNet.numericEnd <= subNet.numericEnd) {
                                                groupEnd = j;
                                            } else {
                                                break;
                                            }
                                        } catch (e) {
                                            // Invalid IP
                                        }
                                    }
                                }

                                this.subscriptionGroups.push({
                                    start: groupStart,
                                    end: groupEnd,
                                    name: subscription,
                                    range: subNet
                                });

                                i = groupEnd + 1;
                                continue;
                            } catch (e) {
                                // Invalid IP
                            }
                        }
                        i++;
                    }
                },

                // Determine the hierarchy level of a row
                getRowLevel(row) {
                    const hasRegion = row.Region && row.Region.trim();
                    const hasSegment = row['Network segment'] && row['Network segment'].trim();
                    const hasMG = row['Management Group'] && row['Management Group'].trim();
                    const hasSubscription = row.Subscription && row.Subscription.trim();
                    const hasVNet = row['VNet name'] && row['VNet name'].trim();
                    const hasSubnetType = row['Subnet type'] && row['Subnet type'].trim();
                    const hasSubnetPurpose = row['Subnet purpose'] && row['Subnet purpose'].trim();
                    const name = (row['Subnet name'] || '').toLowerCase();
                    const comments = (row.Comments || '').toLowerCase();

                    // Check for free space indicators in name (preferred) or comments (legacy)
                    const isFreeSpace = name.includes('free space') ||
                                       name.includes('free scope') ||
                                       name.includes('freespace') ||
                                       comments.includes('free space') ||
                                       comments.includes('free scope') ||
                                       comments.includes('freespace');

                    // Determine level based on what's filled and what's NOT filled
                    // Key insight: level is determined by the LAST filled column in hierarchy

                    // If has subnet type OR subnet purpose (and not free space) -> actual subnet
                    if ((hasSubnetType || hasSubnetPurpose) && !isFreeSpace) {
                        return 'subnet';
                    }

                    // If name/comments indicate free space
                    if (isFreeSpace) {
                        return 'free-space';
                    }

                    // If has VNet but no subnet type/purpose -> VNet level
                    if (hasVNet && !hasSubnetType && !hasSubnetPurpose) {
                        return 'vnet';
                    }

                    // If has Subscription but no VNet -> Subscription level
                    if (hasSubscription && !hasVNet) {
                        return 'subscription';
                    }

                    // If has MG but no Subscription -> MG level
                    if (hasMG && !hasSubscription) {
                        return 'management-group';
                    }

                    // If has Segment but no MG -> Segment level
                    if (hasSegment && !hasMG) {
                        return 'network-segment';
                    }

                    // If has only Region -> Region level
                    if (hasRegion && !hasSegment) {
                        return 'region';
                    }

                    // Default - if we can't determine, check if it looks like a summary row
                    // (has CIDR but missing lower-level identifiers)
                    if (row.Start && row.Start.includes('/')) {
                        if (!hasVNet && !hasSubnetType && !hasSubnetPurpose) {
                            // It's some kind of allocation/summary row
                            if (hasSubscription) return 'subscription';
                            if (hasMG) return 'management-group';
                            if (hasSegment) return 'network-segment';
                            if (hasRegion) return 'region';
                        }
                    }

                    return 'subnet'; // fallback
                },

                validateAll() {
                    this.errors = [];
                    this.warnings = [];
                    this.errorRows = new Set();
                    this.warningRows = new Set();

                    const azureSpecial = ['AzureBastionSubnet', 'GatewaySubnet', 'RouterServerSubnet', 'AzureFirewallSubnet', 'AzureFirewallManagementSubnet'];
                    const networks = [];

                    this.csvData.forEach((row, idx) => {
                        const subnet = row.Start;
                        const purpose = row['Subnet purpose'];
                        const name = row['Subnet name'];
                        const level = this.getRowLevel(row);

                        if (!subnet || !subnet.includes('/')) return;

                        // Validate CIDR format
                        try {
                            const net = this.parseNetwork(subnet);
                            networks.push({ idx: idx + 2, subnet, net, level });

                            // Check if IP is the correct network address (first IP of the range)
                            const enteredIP = subnet.split('/')[0];
                            const correctNetworkIP = this.numericToIP(net.numericStart);
                            if (enteredIP !== correctNetworkIP) {
                                this.errors.push({
                                    row: idx + 2,
                                    message: `Spatna sitova adresa '${subnet}' - spravne by melo byt '${correctNetworkIP}/${net.prefix}'`
                                });
                                this.errorRows.add(idx + 2);
                            }
                        } catch (e) {
                            this.errors.push({ row: idx + 2, message: `Neplatny format IP '${subnet}'` });
                            this.errorRows.add(idx + 2);
                            return;
                        }

                        // Only validate naming for actual subnets (not allocations or free space)
                        if (level === 'subnet') {
                            // Validate naming convention
                            if (purpose && !azureSpecial.includes(purpose)) {
                                const expected = `${purpose}-${subnet.replace('/', '-')}`;
                                if (name && name !== expected) {
                                    this.errors.push({ row: idx + 2, message: `Nesoulad nazvu. Ocekavano '${expected}', je '${name}'` });
                                    this.errorRows.add(idx + 2);
                                }
                            }

                            // Check if purpose is filled but name is empty
                            if (purpose && !name && !azureSpecial.includes(purpose)) {
                                this.warnings.push({ row: idx + 2, message: `Ucel vyplnen, ale nazev chybi` });
                                this.warningRows.add(idx + 2);
                            }
                        }
                    });

                    // Check overlaps - only between subnets at the same level (actual subnets)
                    const actualSubnets = networks.filter(n => n.level === 'subnet' || n.level === 'free-space');
                    for (let i = 0; i < actualSubnets.length; i++) {
                        for (let j = i + 1; j < actualSubnets.length; j++) {
                            const net1 = actualSubnets[i];
                            const net2 = actualSubnets[j];

                            if (this.networksOverlap(net1.net, net2.net)) {
                                // Add ONE error message for the overlap
                                this.errors.push({
                                    row: net1.idx,
                                    row2: net2.idx,
                                    message: `Radky ${net1.idx} a ${net2.idx} se prekryvaji (${net1.subnet} vs ${net2.subnet})`
                                });
                                // Mark BOTH rows as errors (both will be red)
                                this.errorRows.add(net1.idx);
                                this.errorRows.add(net2.idx);
                            }
                        }
                    }

                    // Check IP order - rows should be in ascending order by Start IP
                    let prevNet = null;
                    let prevIdx = null;
                    for (const net of networks) {
                        if (prevNet !== null) {
                            // Check if current IP is less than previous (wrong order)
                            if (net.net.numericStart < prevNet.numericStart) {
                                this.warnings.push({
                                    row: net.idx,
                                    message: `Spatne poradi - ${net.subnet} by mel byt pred radkem ${prevIdx} (${this.numericToIP(prevNet.numericStart)})`
                                });
                                this.warningRows.add(net.idx);
                            }
                        }
                        prevNet = net.net;
                        prevIdx = net.idx;
                    }

                    // Update last validation time
                    const now = new Date();
                    this.lastValidation = now.toLocaleTimeString('cs-CZ');
                },

                getFreeSpaceScope(row) {
                    const name = (row['Subnet name'] || '').toLowerCase();
                    const comments = (row.Comments || '').toLowerCase();
                    if (name.includes('vnet free space')) return 'vnet';
                    if (name.includes('subscription free space')) return 'subscription';
                    if (name.includes('mg free space') || name.includes('management group free space')) return 'management-group';
                    if (name.includes('network segment free space') || name.includes('segment free space')) return 'network-segment';
                    if (comments.includes('vnet free space')) return 'vnet';
                    if (comments.includes('subscription free space')) return 'subscription';
                    if (comments.includes('mg free space') || comments.includes('management group free space')) return 'management-group';
                    if (comments.includes('network segment free space') || comments.includes('segment free space')) return 'network-segment';
                    return null;
                },

                detectGaps() {
                    this.gaps = [];
                    const allNetworks = [];

                    this.csvData.forEach((row, idx) => {
                        if (!row.Start || !row.Start.includes('/')) return;
                        try {
                            const net = this.parseNetwork(row.Start);
                            const level = this.getRowLevel(row);
                            allNetworks.push({
                                idx: idx,
                                rowNum: idx + 2,
                                subnet: row.Start,
                                net: net,
                                row: row,
                                level: level,
                                freeScope: level === 'free-space' ? this.getFreeSpaceScope(row) : null
                            });
                        } catch (e) {
                            // Skip invalid CIDRs
                        }
                    });

                    const scopeLabel = {
                        'vnet': 'VNet',
                        'subscription': 'Subscription',
                        'management-group': 'MG',
                        'network-segment': 'Network segment'
                    };

                    const childPriority = {
                        'vnet': ['subnet'],
                        'subscription': ['vnet', 'subnet'],
                        'management-group': ['subscription', 'vnet', 'subnet'],
                        'network-segment': ['management-group', 'subscription', 'vnet', 'subnet']
                    };

                    const scopeLevels = ['network-segment', 'management-group', 'subscription', 'vnet'];

                    for (const scopeLevel of scopeLevels) {
                        const scopeRows = allNetworks.filter(n => n.level === scopeLevel);

                        for (const scopeRow of scopeRows) {
                            const scopeNet = scopeRow.net;

                            const inside = allNetworks.filter(n => n.idx !== scopeRow.idx &&
                                n.net.numericStart >= scopeNet.numericStart &&
                                n.net.numericEnd <= scopeNet.numericEnd);

                            let chosenLevel = null;
                            for (const candidateLevel of childPriority[scopeLevel]) {
                                if (inside.some(n => n.level === candidateLevel)) {
                                    chosenLevel = candidateLevel;
                                    break;
                                }
                            }

                            let candidates = [];
                            if (chosenLevel) {
                                candidates = inside.filter(n => n.level === chosenLevel);
                            }

                            const freeSpaceCandidates = inside.filter(n => n.level === 'free-space' && n.freeScope === scopeLevel);
                            candidates = candidates.concat(freeSpaceCandidates);

                            // If no candidates, suggest full free space for the scope
                            if (candidates.length === 0) {
                                this.gaps.push({
                                    start: this.numericToIP(scopeNet.numericStart),
                                    end: this.numericToIP(scopeNet.numericEnd),
                                    size: scopeNet.numericEnd - scopeNet.numericStart + 1,
                                    after: scopeRow.subnet,
                                    afterIdx: scopeRow.idx,
                                    afterRow: scopeRow.rowNum,
                                    scopeType: scopeLevel,
                                    scopeLabel: scopeLabel[scopeLevel],
                                    context: scopeRow.row
                                });
                                continue;
                            }

                            candidates.sort((a, b) => a.net.numericStart - b.net.numericStart);

                            let cursor = scopeNet.numericStart;
                            let lastCandidate = null;

                            for (const cand of candidates) {
                                if (cand.net.numericStart > cursor) {
                                    const gapStart = cursor;
                                    const gapEnd = cand.net.numericStart - 1;
                                    this.gaps.push({
                                        start: this.numericToIP(gapStart),
                                        end: this.numericToIP(gapEnd),
                                        size: gapEnd - gapStart + 1,
                                        after: lastCandidate ? lastCandidate.subnet : scopeRow.subnet,
                                        afterIdx: lastCandidate ? lastCandidate.idx : scopeRow.idx,
                                        afterRow: lastCandidate ? lastCandidate.rowNum : scopeRow.rowNum,
                                        scopeType: scopeLevel,
                                        scopeLabel: scopeLabel[scopeLevel],
                                        context: scopeRow.row
                                    });
                                }

                                cursor = Math.max(cursor, cand.net.numericEnd + 1);
                                lastCandidate = cand;
                            }

                            if (cursor <= scopeNet.numericEnd) {
                                this.gaps.push({
                                    start: this.numericToIP(cursor),
                                    end: this.numericToIP(scopeNet.numericEnd),
                                    size: scopeNet.numericEnd - cursor + 1,
                                    after: lastCandidate ? lastCandidate.subnet : scopeRow.subnet,
                                    afterIdx: lastCandidate ? lastCandidate.idx : scopeRow.idx,
                                    afterRow: lastCandidate ? lastCandidate.rowNum : scopeRow.rowNum,
                                    scopeType: scopeLevel,
                                    scopeLabel: scopeLabel[scopeLevel],
                                    context: scopeRow.row
                                });
                            }
                        }
                    }
                },

                fillGap(gap) {
                    this.selectedRowIndex = gap.afterIdx;
                    this.showAddModal = true;

                    const prefix = this.suggestPrefix(gap.size);
                    this.newSubnet = {
                        suggested: `${gap.start}/${prefix}`,
                        prefix: prefix,
                        start: '',
                        addressSpace: '',
                        type: '',
                        purpose: '',
                        name: `${gap.scopeLabel} free space`,
                        available: '',
                        comments: ''
                    };
                    this.updateNewSubnet();
                },

                fillAllGaps() {
                    if (!confirm(`Opravdu chcete automaticky doplnit vsech ${this.gaps.length} mezer?`)) return;

                    // Sort gaps by index descending to preserve indices when inserting
                    const sortedGaps = [...this.gaps].sort((a, b) => b.afterIdx - a.afterIdx);

                    for (const gap of sortedGaps) {
                        const prefix = this.suggestPrefix(gap.size);
                        const net = this.parseNetwork(`${gap.start}/${prefix}`);

                        const templateRow = gap.context;
                        const newRow = {
                            'Region': templateRow.Region || '',
                            'Network segment': templateRow['Network segment'] || '',
                            'Management Group': templateRow['Management Group'] || '',
                            'Subscription': templateRow.Subscription || '',
                            'VNet name': templateRow['VNet name'] || '',
                            'Subnet type': '',
                            'Start': `${gap.start}/${prefix}`,
                            'Address space': `${gap.start} - ${this.numericToIP(net.numericEnd)}`,
                            'Subnet purpose': '',
                            'Subnet name': `${gap.scopeLabel} free space`,
                            'Available addresses': this.calculateAvailableIPs(prefix).toString(),
                            'Comments': ''
                        };

                        this.csvData.splice(gap.afterIdx + 1, 0, newRow);
                    }

                    this.calculateGroups();
                    this.validateAll();
                    this.detectGaps();
                },

                // Editing functionality
                isEditing(rowIndex, column) {
                    return this.editingCell &&
                           this.editingCell.row === rowIndex &&
                           this.editingCell.column === column;
                },

                startEdit(rowIndex, column, event) {
                    this.editingCell = { row: rowIndex, column: column };
                    this.editOriginalValue = this.csvData[rowIndex][column];

                    // Use setTimeout to wait for Vue to render the input
                    setTimeout(() => {
                        const td = event ? event.currentTarget : null;
                        if (td) {
                            const input = td.querySelector('.edit-input');
                            if (input) {
                                input.focus();
                                if (input.select) input.select();
                            }
                        }
                    }, 10);
                },

                stopEdit() {
                    if (this.editingCell) {
                        this.editingCell = null;
                        this.calculateGroups();
                    }
                },

                cancelEdit() {
                    if (this.editingCell) {
                        this.csvData[this.editingCell.row][this.editingCell.column] = this.editOriginalValue;
                        this.editingCell = null;
                    }
                },

                onStartEdit(index) {
                    this.stopEdit();
                    this.recalculateRow(index);
                    this.validateAll();
                    this.detectGaps();
                },

                onPurposeEdit(index) {
                    this.stopEdit();
                    const row = this.csvData[index];
                    const purpose = row['Subnet purpose'];
                    const start = row.Start;

                    const azureSpecial = ['AzureBastionSubnet', 'GatewaySubnet', 'RouterServerSubnet', 'AzureFirewallSubnet', 'AzureFirewallManagementSubnet'];

                    if (purpose && start && start.includes('/') && !azureSpecial.includes(purpose)) {
                        row['Subnet name'] = `${purpose}-${start.replace('/', '-')}`;
                    } else if (!purpose || azureSpecial.includes(purpose)) {
                        row['Subnet name'] = purpose || '';
                    }

                    this.validateAll();
                },

                recalculateRow(index) {
                    const row = this.csvData[index];
                    const start = row.Start;

                    if (!start || !start.includes('/')) return;

                    try {
                        const net = this.parseNetwork(start);
                        row['Address space'] = `${this.numericToIP(net.numericStart)} - ${this.numericToIP(net.numericEnd)}`;
                        row['Available addresses'] = this.calculateAvailableIPs(net.prefix).toString();

                        // Update name if purpose exists
                        const purpose = row['Subnet purpose'];
                        const azureSpecial = ['AzureBastionSubnet', 'GatewaySubnet', 'RouterServerSubnet', 'AzureFirewallSubnet', 'AzureFirewallManagementSubnet'];
                        if (purpose && !azureSpecial.includes(purpose)) {
                            row['Subnet name'] = `${purpose}-${start.replace('/', '-')}`;
                        }
                    } catch (e) {
                        // Invalid CIDR - leave as is
                    }
                },

                recalculateAll() {
                    this.csvData.forEach((row, index) => {
                        this.recalculateRow(index);
                    });
                    this.validateAll();
                    this.detectGaps();
                },

                selectRow(index) {
                    this.selectedRowIndex = index;
                },

                scrollToRow(rowNum) {
                    const element = document.getElementById(`row-${rowNum}`);
                    if (element) {
                        element.scrollIntoView({ behavior: 'smooth', block: 'center' });
                        element.style.boxShadow = '0 0 20px rgba(239, 68, 68, 0.6)';
                        setTimeout(() => {
                            element.style.boxShadow = '';
                        }, 2000);
                    }
                },

                addSubnetAfter(index) {
                    this.selectedRowIndex = index;
                    this.showAddModal = true;

                    const currentRow = this.csvData[index];
                    let nextIP = '';

                    if (currentRow.Start && currentRow.Start.includes('/')) {
                        try {
                            const currentNet = this.parseNetwork(currentRow.Start);
                            nextIP = this.numericToIP(currentNet.numericEnd + 1);
                        } catch (e) {
                            nextIP = '';
                        }
                    }

                    this.newSubnet = {
                        suggested: nextIP ? `${nextIP}/24` : '',
                        prefix: 24,
                        start: '',
                        addressSpace: '',
                        type: currentRow['Subnet type'] || '',
                        purpose: '',
                        name: '',
                        available: '',
                        comments: ''
                    };

                    if (nextIP) {
                        this.updateNewSubnet();
                    }
                },

                duplicateRow(index) {
                    const original = this.csvData[index];
                    const newRow = { ...original };
                    this.csvData.splice(index + 1, 0, newRow);
                    this.calculateGroups();
                },

                deleteRow(index) {
                    if (confirm(`Opravdu chcete smazat radek ${index + 2}?`)) {
                        this.csvData.splice(index, 1);
                        this.calculateGroups();
                        this.validateAll();
                        this.detectGaps();
                    }
                },

                moveRowUp(index) {
                    if (index <= 0) return;
                    const row = this.csvData.splice(index, 1)[0];
                    this.csvData.splice(index - 1, 0, row);
                    this.selectedRowIndex = index - 1;
                    this.calculateGroups();
                    this.validateAll();
                    this.detectGaps();
                },

                moveRowDown(index) {
                    if (index >= this.csvData.length - 1) return;
                    const row = this.csvData.splice(index, 1)[0];
                    this.csvData.splice(index + 1, 0, row);
                    this.selectedRowIndex = index + 1;
                    this.calculateGroups();
                    this.validateAll();
                    this.detectGaps();
                },

                sortByIP() {
                    if (!confirm('Opravdu chcete seradit vsechny radky podle IP adresy?')) return;

                    // Sort rows by Start IP address
                    this.csvData.sort((a, b) => {
                        const aStart = a.Start;
                        const bStart = b.Start;

                        // Rows without Start go to the end
                        if (!aStart || !aStart.includes('/')) return 1;
                        if (!bStart || !bStart.includes('/')) return -1;

                        try {
                            const aNet = this.parseNetwork(aStart);
                            const bNet = this.parseNetwork(bStart);
                            return aNet.numericStart - bNet.numericStart;
                        } catch (e) {
                            return 0;
                        }
                    });

                    this.calculateGroups();
                    this.validateAll();
                    this.detectGaps();
                },

                updateNewSubnetFromSuggested() {
                    const parts = this.newSubnet.suggested.split('/');
                    if (parts.length === 2) {
                        const prefix = parseInt(parts[1]);
                        if (!isNaN(prefix) && prefix >= 16 && prefix <= 30) {
                            this.newSubnet.prefix = prefix;
                        }
                    }
                    this.updateNewSubnet();
                },

                updateNewSubnet() {
                    const startIP = this.newSubnet.suggested.split('/')[0];
                    const prefix = parseInt(this.newSubnet.prefix);

                    if (!startIP || !this.isValidIP(startIP)) {
                        this.newSubnet.start = '';
                        this.newSubnet.addressSpace = '';
                        this.newSubnet.available = '';
                        return;
                    }

                    try {
                        const net = this.parseNetwork(`${startIP}/${prefix}`);

                        this.newSubnet.start = `${startIP}/${prefix}`;
                        this.newSubnet.addressSpace = `${startIP} - ${this.numericToIP(net.numericEnd)}`;
                        this.newSubnet.available = this.calculateAvailableIPs(prefix).toString();

                        this.updateSubnetName();
                    } catch (e) {
                        // Invalid input
                    }
                },

                updateSubnetName() {
                    const currentName = (this.newSubnet.name || '').toLowerCase();
                    if (this.newSubnet.purpose && this.newSubnet.purpose.toLowerCase() !== 'free space') {
                        this.newSubnet.name = `${this.newSubnet.purpose}-${this.newSubnet.start.replace('/', '-')}`;
                    } else if (!currentName.includes('free space')) {
                        this.newSubnet.name = '';
                    }
                },

                confirmAddSubnet() {
                    const templateRow = this.csvData[this.selectedRowIndex];

                    const newRow = {
                        'Region': templateRow.Region || '',
                        'Network segment': templateRow['Network segment'] || '',
                        'Management Group': templateRow['Management Group'] || '',
                        'Subscription': templateRow.Subscription || '',
                        'VNet name': templateRow['VNet name'] || '',
                        'Subnet type': this.newSubnet.type,
                        'Start': this.newSubnet.start,
                        'Address space': this.newSubnet.addressSpace,
                        'Subnet purpose': this.newSubnet.purpose,
                        'Subnet name': this.newSubnet.name,
                        'Available addresses': this.newSubnet.available,
                        'Comments': this.newSubnet.comments
                    };

                    this.csvData.splice(this.selectedRowIndex + 1, 0, newRow);
                    this.showAddModal = false;
                    this.calculateGroups();
                    this.validateAll();
                    this.detectGaps();
                },

                getRowClass(row, index) {
                    const classes = [];

                    // Check for errors/warnings
                    const rowNum = index + 2;
                    if (this.errorRows.has(rowNum)) {
                        classes.push('row-error');
                    } else if (this.warningRows.has(rowNum)) {
                        classes.push('row-warning');
                    }

                    return classes.join(' ');
                },

                // Get border classes for a cell based on hierarchy grouping
                // Columns: 0=Region, 1=Segment, 2=MG, 3=Subscription, 4=VNet, 5-12=rest
                getCellBorderClass(row, colIndex, index) {
                    const classes = [];

                    // Find which groups this row belongs to
                    const segmentGroup = this.segmentGroups.find(g => index >= g.start && index <= g.end);
                    const mgGroup = this.mgGroups.find(g => index >= g.start && index <= g.end);
                    const subscriptionGroup = this.subscriptionGroups.find(g => index >= g.start && index <= g.end);
                    const vnetGroup = this.vnetGroups.find(g => index >= g.start && index <= g.end);

                    // Network Segment border - starts from column 1
                    if (segmentGroup && colIndex >= 1) {
                        const hasInnerBorder = (mgGroup && colIndex >= 2) || (subscriptionGroup && colIndex >= 3) || (vnetGroup && colIndex >= 4);

                        if (colIndex === 1) {
                            classes.push('seg-border-left');
                            if (index === segmentGroup.start) classes.push('seg-border-top');
                            if (index === segmentGroup.end) classes.push('seg-border-bottom');
                        }

                        if (!hasInnerBorder) {
                            if (index === segmentGroup.start && colIndex > 1) classes.push('seg-border-top');
                            if (index === segmentGroup.end && colIndex > 1) classes.push('seg-border-bottom');
                            if (colIndex === 12) classes.push('seg-border-right');
                        }
                    }

                    // Management Group border - starts from column 2
                    if (mgGroup && colIndex >= 2) {
                        const hasInnerBorder = (subscriptionGroup && colIndex >= 3) || (vnetGroup && colIndex >= 4);

                        if (colIndex === 2) {
                            classes.push('mg-border-left');
                            if (index === mgGroup.start) classes.push('mg-border-top');
                            if (index === mgGroup.end) classes.push('mg-border-bottom');
                        }

                        if (!hasInnerBorder) {
                            if (index === mgGroup.start && colIndex > 2) classes.push('mg-border-top');
                            if (index === mgGroup.end && colIndex > 2) classes.push('mg-border-bottom');
                            if (colIndex === 12) classes.push('mg-border-right');
                        }
                    }

                    // Subscription border - starts from column 3
                    if (subscriptionGroup && colIndex >= 3) {
                        const hasInnerBorder = vnetGroup && colIndex >= 4;

                        if (colIndex === 3) {
                            classes.push('sub-border-left');
                            if (index === subscriptionGroup.start) classes.push('sub-border-top');
                            if (index === subscriptionGroup.end) classes.push('sub-border-bottom');
                        }

                        if (!hasInnerBorder) {
                            if (index === subscriptionGroup.start && colIndex > 3) classes.push('sub-border-top');
                            if (index === subscriptionGroup.end && colIndex > 3) classes.push('sub-border-bottom');
                            if (colIndex === 12) classes.push('sub-border-right');
                        }
                    }

                    // VNet border - starts from column 4
                    if (vnetGroup && colIndex >= 4) {
                        if (colIndex === 4) classes.push('vnet-border-left');
                        if (index === vnetGroup.start) classes.push('vnet-border-top');
                        if (index === vnetGroup.end) classes.push('vnet-border-bottom');
                        if (colIndex === 12) classes.push('vnet-border-right');
                    }

                    return classes.join(' ');
                },

                // Get cell class based on column position and row level
                getCellClass(row, colIndex, index) {
                    const rowNum = index + 2;

                    // Error/warning takes priority
                    if (this.errorRows.has(rowNum)) {
                        return 'cell-error';
                    }
                    if (this.warningRows.has(rowNum)) {
                        return 'cell-warning';
                    }

                    // Determine the first filled column index (hierarchy columns 0-4)
                    // 0=Region, 1=Segment, 2=MG, 3=Subscription, 4=VNet
                    const hasRegion = row.Region && row.Region.trim();
                    const hasSegment = row['Network segment'] && row['Network segment'].trim();
                    const hasMG = row['Management Group'] && row['Management Group'].trim();
                    const hasSubscription = row.Subscription && row.Subscription.trim();
                    const hasVNet = row['VNet name'] && row['VNet name'].trim();

                    let firstFilledCol = -1;
                    if (hasRegion) firstFilledCol = 0;
                    else if (hasSegment) firstFilledCol = 1;
                    else if (hasMG) firstFilledCol = 2;
                    else if (hasSubscription) firstFilledCol = 3;
                    else if (hasVNet) firstFilledCol = 4;
                    else firstFilledCol = 5; // Start from Type/Start columns

                    // If this column is before the first filled, keep it white
                    if (colIndex < firstFilledCol) {
                        return 'cell-white';
                    }

                    // Get level and return appropriate color class
                    const level = this.getRowLevel(row);
                    const colorMap = {
                        'region': 'cell-region',
                        'network-segment': 'cell-segment',
                        'management-group': 'cell-mg',
                        'subscription': 'cell-subscription',
                        'vnet': 'cell-vnet',
                        'subnet': 'cell-subnet',
                        'free-space': 'cell-free-space'
                    };
                    return colorMap[level] || 'cell-white';
                },

                exportCSV() {
                    const headers = Object.keys(this.csvData[0]);
                    let csv = headers.join(';') + '\n';

                    this.csvData.forEach(row => {
                        csv += headers.map(h => row[h] || '').join(';') + '\n';
                    });

                    const blob = new Blob(['\uFEFF' + csv], { type: 'text/csv;charset=utf-8;' });
                    const link = document.createElement('a');
                    link.href = URL.createObjectURL(blob);
                    link.download = 'IP_Plan_Updated.csv';
                    link.click();
                },

                reset() {
                    if (confirm('Opravdu chcete zrusit vsechny zmeny a nacist novy soubor?')) {
                        this.csvData = [];
                        this.errors = [];
                        this.warnings = [];
                        this.gaps = [];
                        this.errorRows = new Set();
                        this.warningRows = new Set();
                        this.editingCell = null;
                        this.selectedRowIndex = -1;
                        this.lastValidation = '';
                        this.sidePanelOpen = false;
                        this.segmentGroups = [];
                        this.mgGroups = [];
                        this.subscriptionGroups = [];
                        this.vnetGroups = [];
                    }
                },

                createNewPlan() {
                    // Create empty row template
                    const emptyRow = {
                        'Region': '',
                        'Network segment': '',
                        'Management Group': '',
                        'Subscription': '',
                        'VNet name': '',
                        'Subnet type': '',
                        'Start': '',
                        'Address space': '',
                        'Subnet purpose': '',
                        'Subnet name': '',
                        'Available addresses': '',
                        'Comments': ''
                    };

                    // Create a few starter rows
                    this.csvData = [
                        { ...emptyRow, 'Region': 'West Europe (WE)' },
                        { ...emptyRow },
                        { ...emptyRow },
                        { ...emptyRow },
                        { ...emptyRow }
                    ];

                    this.errors = [];
                    this.warnings = [];
                    this.gaps = [];
                    this.errorRows = new Set();
                    this.warningRows = new Set();
                    this.calculateGroups();
                },

                // IP Utilities
                parseNetwork(cidr) {
                    const [ip, prefix] = cidr.split('/');
                    const prefixNum = parseInt(prefix);

                    if (!this.isValidIP(ip) || isNaN(prefixNum) || prefixNum < 0 || prefixNum > 32) {
                        throw new Error('Invalid CIDR');
                    }

                    const ipParts = ip.split('.').map(p => parseInt(p));

                    const numericIP = (ipParts[0] << 24) + (ipParts[1] << 16) + (ipParts[2] << 8) + ipParts[3];
                    const mask = prefixNum === 0 ? 0 : (0xFFFFFFFF << (32 - prefixNum)) >>> 0;
                    const networkStart = (numericIP & mask) >>> 0;
                    const networkEnd = (networkStart | (~mask >>> 0)) >>> 0;

                    return {
                        ip,
                        prefix: prefixNum,
                        numericStart: networkStart,
                        numericEnd: networkEnd,
                        mask
                    };
                },

                isValidIP(ip) {
                    const parts = ip.split('.');
                    if (parts.length !== 4) return false;
                    return parts.every(p => {
                        const num = parseInt(p);
                        return !isNaN(num) && num >= 0 && num <= 255 && p === num.toString();
                    });
                },

                numericToIP(num) {
                    return [
                        (num >>> 24) & 0xFF,
                        (num >>> 16) & 0xFF,
                        (num >>> 8) & 0xFF,
                        num & 0xFF
                    ].join('.');
                },

                networksOverlap(net1, net2) {
                    return (net1.numericStart <= net2.numericEnd && net1.numericEnd >= net2.numericStart);
                },

                isSubnetOf(child, parent) {
                    return child.numericStart >= parent.numericStart &&
                           child.numericEnd <= parent.numericEnd &&
                           child.prefix > parent.prefix;
                },

                calculateAvailableIPs(prefix) {
                    const total = Math.pow(2, 32 - prefix);
                    // Azure reserves 5 IPs per subnet
                    return Math.max(0, total - 5);
                },

                suggestPrefix(size) {
                    for (let prefix = 30; prefix >= 16; prefix--) {
                        const available = Math.pow(2, 32 - prefix);
                        if (available >= size) return prefix;
                    }
                    return 24;
                },

                formatNumber(num) {
                    return new Intl.NumberFormat('cs-CZ').format(num);
                }
            }
        }).mount('#app');
    </script>
</body>
</html>
