<!DOCTYPE html>
<html lang="cs">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>IP Plan Validator v2</title>
    <script src="https://cdn.jsdelivr.net/npm/vue@3.4.15/dist/vue.global.prod.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
    <style>
        [v-cloak] { display: none; }

        * {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
        }

        .font-mono, .mono {
            font-family: 'JetBrains Mono', 'Consolas', monospace !important;
        }

        /* Hierarchical coloring - applied per cell, not per row */
        /* Colors defined as CSS variables for use in JavaScript */
        :root {
            --color-region: #C6EFCE;
            --color-segment: #A9D08E;
            --color-mg: #70AD47;
            --color-subscription: #92D050;
            --color-vnet: #FFC000;
            --color-subnet: #FFFFFF;
            --color-free-space: #E7E6E6;
        }

        /* Cell coloring classes */
        td.cell-region { background-color: #C6EFCE !important; }
        td.cell-segment { background-color: #A9D08E !important; }
        td.cell-mg { background-color: #70AD47 !important; color: white; }
        td.cell-subscription { background-color: #92D050 !important; }
        td.cell-vnet { background-color: #FFC000 !important; }
        td.cell-subnet { background-color: #FFFFFF !important; }
        td.cell-free-space { background-color: #E7E6E6 !important; color: #666; }
        td.cell-white { background-color: #FFFFFF !important; }

        /* Error states - higher priority */
        td.cell-error {
            background-color: #FFC7CE !important;
            color: #9C0006 !important;
        }
        tr.row-error {
            border-left: 5px solid #C00000 !important;
        }

        td.cell-warning {
            background-color: #FFEB9C !important;
            color: #9C5700 !important;
        }
        tr.row-warning {
            border-left: 5px solid #FF9900 !important;
        }

        /* Header styling - all blue */
        .header-calculated,
        .header-editable {
            background: linear-gradient(135deg, #3498DB 0%, #2980B9 100%) !important;
            color: white !important;
            font-weight: 600;
            text-shadow: 0 1px 2px rgba(0,0,0,0.2);
        }

        .row-hover:hover {
            filter: brightness(0.95);
            cursor: pointer;
        }
        .row-selected > td {
            box-shadow: inset 0 0 0 2px #2563eb !important;
        }

        /* Network Segment grouping borders - light green */
        td.seg-border-top { border-top: 3px solid #A9D08E !important; }
        td.seg-border-bottom { border-bottom: 3px solid #A9D08E !important; }
        td.seg-border-left { border-left: 3px solid #A9D08E !important; }
        td.seg-border-right { border-right: 3px solid #A9D08E !important; }

        /* Management Group borders - darker green */
        td.mg-border-top { border-top: 3px solid #70AD47 !important; }
        td.mg-border-bottom { border-bottom: 3px solid #70AD47 !important; }
        td.mg-border-left { border-left: 3px solid #70AD47 !important; }
        td.mg-border-right { border-right: 3px solid #70AD47 !important; }

        /* Subscription grouping borders - yellow-green */
        td.sub-border-top { border-top: 3px solid #92D050 !important; }
        td.sub-border-bottom { border-bottom: 3px solid #92D050 !important; }
        td.sub-border-left { border-left: 3px solid #92D050 !important; }
        td.sub-border-right { border-right: 3px solid #92D050 !important; }

        /* VNet grouping borders - yellow/orange */
        td.vnet-border-top { border-top: 3px solid #FFC000 !important; }
        td.vnet-border-bottom { border-bottom: 3px solid #FFC000 !important; }
        td.vnet-border-left { border-left: 3px solid #FFC000 !important; }
        td.vnet-border-right { border-right: 3px solid #FFC000 !important; }

        table {
            border-collapse: collapse;
            width: 100%;
            font-size: 11px;
        }
        thead {
            box-shadow: 0 1px 2px rgba(0,0,0,0.1);
        }
        tbody tr {
            border: 1px solid #E0E0E0;
        }
        th {
            border: 1px solid rgba(255,255,255,0.2);
            padding: 6px 6px !important;
            white-space: nowrap;
            font-size: 10px;
            text-transform: uppercase;
            letter-spacing: 0.3px;
        }
        td {
            border-right: 1px solid #E8E8E8;
            padding: 3px 6px !important;
        }

        /* Editable cell styling */
        .editable-cell {
            cursor: text;
            min-width: 40px;
        }
        .editable-cell:hover {
            background-color: rgba(52, 152, 219, 0.15) !important;
            cursor: pointer;
        }
        .editing-cell {
            padding: 0 !important;
            background-color: #EBF5FB !important;
        }
        .edit-input {
            width: 100%;
            padding: 3px 6px;
            border: 2px solid #3498DB !important;
            outline: none;
            font-size: inherit;
            font-family: inherit;
            background: white !important;
            box-sizing: border-box;
        }
        .edit-input:focus {
            background: #FFF9C4 !important;
        }

        /* Stats cards - compact */
        .stat-card {
            background: white;
            border-radius: 8px;
            padding: 8px 12px;
            box-shadow: 0 1px 4px rgba(0,0,0,0.06);
            border: 1px solid #E8E8E8;
        }
        .stat-card.error { border-left: 3px solid #E74C3C; }
        .stat-card.warning { border-left: 3px solid #F39C12; }
        .stat-card.info { border-left: 3px solid #3498DB; }
        .stat-card.success { border-left: 3px solid #27AE60; }

        /* Buttons */
        .btn {
            padding: 6px 12px;
            border-radius: 5px;
            font-weight: 500;
            font-size: 11px;
            border: none;
            cursor: pointer;
            display: inline-flex;
            align-items: center;
            gap: 4px;
        }
        .btn:hover { opacity: 0.9; }
        .btn-primary { background: #3498DB; color: white; }
        .btn-success { background: #27AE60; color: white; }
        .btn-purple { background: #9B59B6; color: white; }
        .btn-indigo { background: #5C6BC0; color: white; }
        .btn-orange { background: #E67E22; color: white; }
        .btn-gray { background: #7F8C8D; color: white; }
        .btn-danger { background: #E74C3C; color: white; }
        .btn:disabled { opacity: 0.5; cursor: not-allowed; }

        /* Action buttons in table */
        .action-btn {
            width: 18px;
            height: 18px;
            border-radius: 3px;
            border: none;
            cursor: pointer;
            font-size: 10px;
            font-weight: 600;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            margin: 0 1px;
        }
        .action-btn:hover { opacity: 0.8; }
        .action-btn.add { background: #E3F2FD; color: #1976D2; }
        .action-btn.dup { background: #E8F5E9; color: #388E3C; }
        .action-btn.del { background: #FFEBEE; color: #D32F2F; }
        .action-btn.up { background: #FFF3E0; color: #E65100; }
        .action-btn.down { background: #FFF3E0; color: #E65100; }
        .action-btn:disabled { opacity: 0.3; cursor: not-allowed; }
        .action-btn.ok { background: #E8F5E9; color: #2E7D32; }
        .action-btn.cancel { background: #FFEBEE; color: #C62828; }

        /* Legend - compact inline */
        .legend-item {
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 10px;
            font-weight: 500;
            border: 1px solid rgba(0,0,0,0.1);
        }

        /* Side panel */
        .side-panel {
            position: fixed;
            right: 0;
            top: 0;
            width: 320px;
            height: 100vh;
            background: white;
            box-shadow: -4px 0 20px rgba(0,0,0,0.1);
            z-index: 40;
            overflow-y: auto;
            padding: 16px;
            transform: translateX(100%);
            transition: transform 0.3s ease;
        }
        .side-panel.open {
            transform: translateX(0);
        }
        .side-panel-toggle {
            position: fixed;
            right: 0;
            top: 50%;
            transform: translateY(-50%);
            background: white;
            border: 1px solid #ddd;
            border-right: none;
            border-radius: 8px 0 0 8px;
            padding: 12px 8px;
            cursor: pointer;
            z-index: 41;
            box-shadow: -2px 0 8px rgba(0,0,0,0.1);
            writing-mode: vertical-rl;
            font-size: 12px;
            font-weight: 600;
        }
        .side-panel-toggle:hover {
            background: #f5f5f5;
        }
        .side-panel-toggle.has-errors {
            background: #FFC7CE;
            color: #9C0006;
        }
        .side-panel.open + .side-panel-toggle {
            right: 320px;
        }

        /* Panels - compact */
        .panel {
            border-radius: 8px;
            padding: 10px;
            margin-bottom: 10px;
        }
        .panel-error {
            background: #FFF5F5;
            border: 1px solid #FED7D7;
        }
        .panel-warning {
            background: #FFFBEB;
            border: 1px solid #FEF3C7;
        }
        .panel-info {
            background: #EFF6FF;
            border: 1px solid #DBEAFE;
        }

        /* Scrollbar */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }
        ::-webkit-scrollbar-track {
            background: #F1F1F1;
            border-radius: 4px;
        }
        ::-webkit-scrollbar-thumb {
            background: #C1C1C1;
            border-radius: 4px;
        }
        ::-webkit-scrollbar-thumb:hover {
            background: #A1A1A1;
        }

        /* Table container */
        .table-container {
            background: white;
            border-radius: 6px;
            box-shadow: 0 1px 4px rgba(0,0,0,0.06);
            overflow: hidden;
        }
        .table-scroll {
            overflow-x: auto;
            max-height: calc(100vh - 130px);
            overflow-y: auto;
        }

        /* Main content with side panel */
        .main-content {
            transition: margin-right 0.3s ease;
        }
        .main-content.panel-open {
            margin-right: 330px;
        }

        /* Modal */
        .modal-overlay {
            background: rgba(0, 0, 0, 0.5);
        }
        .modal-content {
            background: white;
            border-radius: 10px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
        }

        /* Tooltips */
        .has-tooltip {
            position: relative;
        }
        .tooltip {
            position: absolute;
            bottom: 125%;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(15, 23, 42, 0.95);
            color: white;
            padding: 6px 8px;
            border-radius: 6px;
            font-size: 11px;
            line-height: 1.3;
            white-space: nowrap;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.15s ease;
            z-index: 9999;
        }
        .has-tooltip:hover .tooltip {
            opacity: 1;
        }

        /* Highlight rows */
        tr.row-highlight > td {
            box-shadow: inset 0 0 0 2px #f59e0b !important;
            background-color: #fff7ed !important;
        }
    </style>
</head>
<body class="bg-gray-50">
    <div id="app" v-cloak class="p-3 max-w-full">
        <div class="flex items-center justify-between mb-3" v-if="!csvData.length">
            <h1 class="text-2xl font-bold text-gray-800">IP Plan Validator</h1>
        </div>

        <!-- File Upload / New Plan -->
        <div v-if="!csvData.length" class="mb-4">
            <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                <!-- Upload existing file -->
                <div class="border-2 border-dashed border-gray-300 rounded-lg p-8 text-center bg-white hover:border-blue-400 hover:bg-blue-50 transition-all cursor-pointer"
                     @dragover.prevent="dragOver = true"
                     @dragleave.prevent="dragOver = false"
                     @drop.prevent="handleFileDrop"
                     :class="{ 'border-blue-500 bg-blue-50': dragOver }">
                    <svg class="w-12 h-12 mx-auto mb-3 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12"/>
                    </svg>
                    <p class="text-lg font-medium text-gray-700 mb-2">Nacist existujici plan</p>
                    <p class="text-sm text-gray-500 mb-3">Pretahni CSV soubor sem nebo</p>
                    <label class="cursor-pointer">
                        <span class="btn btn-primary px-6 py-2">Vyber soubor</span>
                        <input type="file" accept=".csv" @change="handleFileSelect" class="hidden">
                    </label>
                    <p class="text-xs text-gray-400 mt-3">Format: CSV s oddelovacem strednik (;)</p>
                </div>

                <!-- Create new plan -->
                <div class="border-2 border-dashed border-green-300 rounded-lg p-8 text-center bg-white hover:border-green-400 hover:bg-green-50 transition-all cursor-pointer"
                     @click="createNewPlan">
                    <svg class="w-12 h-12 mx-auto mb-3 text-green-500" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 6v6m0 0v6m0-6h6m-6 0H6"/>
                    </svg>
                    <p class="text-lg font-medium text-gray-700 mb-2">Vytvorit novy plan</p>
                    <p class="text-sm text-gray-500 mb-3">Zacni s prazdnou tabulkou</p>
                    <span class="btn btn-success px-6 py-2">Novy IP plan</span>
                    <p class="text-xs text-gray-400 mt-3">Vytvoris novou strukturu od zacatku</p>
                </div>
            </div>
        </div>

        <!-- Main Content -->
            <div v-if="csvData.length" class="main-content" :class="{ 'panel-open': sidePanelOpen }">
            <!-- Compact toolbar -->
            <div class="flex items-center justify-between gap-4 mb-3 flex-wrap">
                <!-- Stats inline -->
                <div class="flex items-center gap-3 text-sm">
                    <span class="text-gray-600 has-tooltip">Radku: <strong>{{ csvData.length }}</strong><span class="tooltip">Celkovy pocet radku v tabulce</span></span>
                    <span class="text-gray-400">|</span>
                    <span class="text-green-600 has-tooltip">Subnety: <strong>{{ totalSubnets }}</strong><span class="tooltip">Radky s realnou podsiti</span></span>
                    <span class="text-gray-400">|</span>
                    <span class="text-gray-500 has-tooltip">Free spaces: <strong>{{ totalFreeSpace }}</strong><span class="tooltip">Radky oznacene jako free space</span></span>
                    <span class="text-gray-400">|</span>
                    <span class="text-red-600 cursor-pointer hover:underline has-tooltip" @click="sidePanelOpen = true" v-if="errorRows.size">Chyby: <strong>{{ errorRows.size }}</strong><span class="tooltip">Nalezene chyby v datech</span></span>
                    <span class="text-green-600 has-tooltip" v-else>Chyby: <strong>0</strong><span class="tooltip">Zadne chyby</span></span>
                    <span class="text-gray-400">|</span>
                    <span class="text-yellow-600 cursor-pointer hover:underline has-tooltip" @click="sidePanelOpen = true" v-if="warnings.length">Varovani: <strong>{{ warnings.length }}</strong><span class="tooltip">Upozorneni (napr. poradi IP)</span></span>
                    <span class="text-gray-500 has-tooltip" v-else>Varovani: <strong>0</strong><span class="tooltip">Zadne varovani</span></span>
                    <span class="text-gray-400">|</span>
                    <span class="text-blue-600 cursor-pointer hover:underline has-tooltip" @click="sidePanelOpen = true" v-if="gaps.length">Gaps: <strong>{{ gaps.length }}</strong><span class="tooltip">Nalezene mezery v IP rozsazich</span></span>
                    <span class="text-gray-500 has-tooltip" v-else>Gaps: <strong>0</strong><span class="tooltip">Zadne mezery</span></span>
                </div>

                <!-- Legend inline -->
                <div class="flex items-center gap-2 flex-wrap justify-end">
                    <div class="flex items-center gap-1 flex-wrap justify-end">
                        <span class="legend-item" style="background-color: #C6EFCE;">Reg</span>
                        <span class="legend-item" style="background-color: #A9D08E;">Seg</span>
                        <span class="legend-item" style="background-color: #70AD47; color: white;">MG</span>
                        <span class="legend-item" style="background-color: #92D050;">Sub</span>
                        <span class="legend-item" style="background-color: #FFC000;">VNet</span>
                        <span class="legend-item" style="background-color: #FFFFFF;">Subnet</span>
                        <span class="legend-item" style="background-color: #E7E6E6;">Free</span>
                        <span class="legend-item" style="background-color: #FFC7CE; color: #9C0006;">Err</span>
                    </div>
                    <button @click="exportCSV" class="btn btn-gray text-xs px-3 py-2 has-tooltip">
                        Export
                        <span class="tooltip">Stahne aktualni CSV</span>
                    </button>
                    <button @click="reset" class="btn btn-danger text-xs px-3 py-2 has-tooltip">
                        Novy soubor
                        <span class="tooltip">Zahodi zmeny a vrati uvodni obrazovku</span>
                    </button>
                </div>
            </div>

            <!-- Actions -->
            <div class="mb-2 flex flex-wrap gap-2">
                <button @click="validateAll" class="btn btn-primary text-xs px-3 py-2 has-tooltip">
                    Validovat
                    <span class="tooltip">Zkontroluje format, prekryvy a poradi IP</span>
                </button>
                <!-- Free space helper moved to side panel only -->
                <button @click="recalculateAll" class="btn btn-indigo text-xs px-3 py-2 has-tooltip">
                    Aktualizovat vypocty
                    <span class="tooltip">Prepocita Address space, IPs a Subnet name</span>
                </button>
                <button @click="sidePanelOpen = !sidePanelOpen" class="btn text-xs px-3 py-2 has-tooltip" :class="hasIssues ? 'btn-danger' : 'btn-gray'">
                    {{ sidePanelOpen ? 'Skryt' : 'Zobrazit' }} problemy ({{ errorRows.size + warnings.length + gaps.length }})
                    <span class="tooltip">Panel s chybami, varovanimi a mezerami</span>
                </button>
                <button @click="showFilters = !showFilters" class="btn text-xs px-3 py-2 btn-gray has-tooltip">
                    {{ showFilters ? 'Skryt' : 'Zobrazit' }} filtry
                    <span class="tooltip">Filtry pro tabulku a free space helper</span>
                </button>
            </div>
            <div v-if="autoFixNotice" class="mb-3 text-xs text-orange-700 bg-orange-50 border border-orange-200 rounded px-3 py-2">
                {{ autoFixNotice }}
            </div>

            <!-- Filters -->
            <div v-if="showFilters" class="mb-3 bg-white border rounded p-3 text-xs text-gray-700 shadow-sm">
                <div class="font-semibold text-gray-800 mb-2">Filtry hlavni tabulky</div>
                <div class="grid grid-cols-1 md:grid-cols-4 gap-3 mb-3">
                    <div>
                        <label class="block text-[11px] font-medium text-gray-600 mb-1">Network segment</label>
                        <select v-model="tableFilter.segment" class="w-full p-2 border rounded text-xs">
                            <option value="">All</option>
                            <option v-for="s in tableFilterOptions.segment" :key="s" :value="s">{{ s }}</option>
                        </select>
                    </div>
                    <div>
                        <label class="block text-[11px] font-medium text-gray-600 mb-1">MG</label>
                        <select v-model="tableFilter.managementGroup" class="w-full p-2 border rounded text-xs">
                            <option value="">All</option>
                            <option v-for="m in tableFilterOptions.managementGroup" :key="m" :value="m">{{ m }}</option>
                        </select>
                    </div>
                    <div>
                        <label class="block text-[11px] font-medium text-gray-600 mb-1">Subscription</label>
                        <select v-model="tableFilter.subscription" class="w-full p-2 border rounded text-xs">
                            <option value="">All</option>
                            <option v-for="s in tableFilterOptions.subscription" :key="s" :value="s">{{ s }}</option>
                        </select>
                    </div>
                    <div>
                        <label class="block text-[11px] font-medium text-gray-600 mb-1">VNet</label>
                        <select v-model="tableFilter.vnet" class="w-full p-2 border rounded text-xs">
                            <option value="">All</option>
                            <option v-for="v in tableFilterOptions.vnet" :key="v" :value="v">{{ v }}</option>
                        </select>
                    </div>
                </div>

                <div class="font-semibold text-gray-800 mb-2">Free space filtry</div>
                <div class="flex flex-wrap items-center gap-3 text-xs text-gray-600">
                    <label class="flex items-center gap-1 cursor-pointer">
                        <input type="checkbox" v-model="freeSpaceFilter.networkSegment" @change="detectGaps">
                        Network segment
                    </label>
                    <label class="flex items-center gap-1 cursor-pointer">
                        <input type="checkbox" v-model="freeSpaceFilter.managementGroup" @change="detectGaps">
                        MG
                    </label>
                    <label class="flex items-center gap-1 cursor-pointer">
                        <input type="checkbox" v-model="freeSpaceFilter.subscription" @change="detectGaps">
                        Subscription
                    </label>
                    <label class="flex items-center gap-1 cursor-pointer">
                        <input type="checkbox" v-model="freeSpaceFilter.vnet" @change="detectGaps">
                        VNet
                    </label>
                    <button class="text-xs text-blue-600 hover:underline" @click="setAllFreeSpaceFilters(true); detectGaps()">All</button>
                    <button class="text-xs text-blue-600 hover:underline" @click="setAllFreeSpaceFilters(false); detectGaps()">None</button>
                </div>
            </div>

            <!-- Data Table -->
            <div class="table-container">
                <div class="table-scroll">
                    <table class="min-w-full">
                    <thead class="sticky top-0 z-10">
                        <tr>
                            <th class="px-2 py-2 text-left header-editable">#</th>
                            <th class="px-2 py-2 text-left header-editable">Region</th>
                            <th class="px-2 py-2 text-left header-editable">Network Segment</th>
                            <th class="px-2 py-2 text-left header-editable">MANAGEMENT GROUP</th>
                            <th class="px-2 py-2 text-left header-editable">Subscription</th>
                            <th class="px-2 py-2 text-left header-editable">VNet</th>
                            <th class="px-2 py-2 text-left header-editable">SUBNET TYPE</th>
                            <th class="px-2 py-2 text-left header-calculated">Start</th>
                            <th class="px-2 py-2 text-left header-calculated">Address Space</th>
                            <th class="px-2 py-2 text-left header-editable">Purpose</th>
                            <th class="px-2 py-2 text-left header-calculated cursor-pointer hover:bg-blue-700" @dblclick="showNamingModal = true" title="Dvojklik pro nastaveni vzoru nazvu">SUBNET NAME</th>
                            <th class="px-2 py-2 text-left header-calculated">IPs</th>
                            <th class="px-2 py-2 text-left header-editable">Comments</th>
                            <th class="px-2 py-2 text-left header-editable">Akce</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr v-for="item in filteredRows"
                            :key="item.index"
                            :id="'row-' + (item.index + 2)"
                            :class="[getRowClass(item.row, item.index), 'border-t row-hover', selectedRowIndex === item.index ? 'row-selected' : '', highlightedRows.has(item.index) ? 'row-highlight' : '']"
                            @click="selectRow(item.index)">
                            <td class="px-2 py-2 text-gray-500 bg-white">{{ item.index + 2 }}</td>

                            <!-- Region - editable (colIndex 0) -->
                            <td class="px-2 py-2 editable-cell" :class="[getCellClass(item.row, 0, item.index), getCellBorderClass(item.row, 0, item.index), {'editing-cell': isEditing(item.index, 'Region')}]" @dblclick.stop="startEdit(item.index, 'Region', $event)">
                                <input v-if="isEditing(item.index, 'Region')"
                                       v-model="item.row.Region"
                                       @blur="stopEdit"
                                       @keyup.enter="stopEdit"
                                       @keyup.escape="cancelEdit"
                                       class="w-full edit-input">
                                <span v-else>{{ item.row.Region }}</span>
                            </td>

                            <!-- Network segment - editable (colIndex 1) -->
                            <td class="px-2 py-2 editable-cell" :class="[getCellClass(item.row, 1, item.index), getCellBorderClass(item.row, 1, item.index), {'editing-cell': isEditing(item.index, 'Network segment')}]" @dblclick.stop="startEdit(item.index, 'Network segment', $event)">
                                <input v-if="isEditing(item.index, 'Network segment')"
                                       v-model="item.row['Network segment']"
                                       @blur="stopEdit"
                                       @keyup.enter="stopEdit"
                                       @keyup.escape="cancelEdit"
                                       class="edit-input">
                                <span v-else>{{ item.row['Network segment'] }}</span>
                            </td>

                            <!-- Management Group - editable (colIndex 2) -->
                            <td class="px-2 py-2 editable-cell" :class="[getCellClass(item.row, 2, item.index), getCellBorderClass(item.row, 2, item.index), {'editing-cell': isEditing(item.index, 'Management Group')}]" @dblclick.stop="startEdit(item.index, 'Management Group', $event)">
                                <input v-if="isEditing(item.index, 'Management Group')"
                                       v-model="item.row['Management Group']"
                                       @blur="stopEdit"
                                       @keyup.enter="stopEdit"
                                       @keyup.escape="cancelEdit"
                                       class="edit-input">
                                <span v-else>{{ item.row['Management Group'] }}</span>
                            </td>

                            <!-- Subscription - editable (colIndex 3) -->
                            <td class="px-2 py-2 font-medium editable-cell" :class="[getCellClass(item.row, 3, item.index), getCellBorderClass(item.row, 3, item.index), {'editing-cell': isEditing(item.index, 'Subscription')}]" @dblclick.stop="startEdit(item.index, 'Subscription', $event)">
                                <input v-if="isEditing(item.index, 'Subscription')"
                                       v-model="item.row.Subscription"
                                       @blur="stopEdit"
                                       @keyup.enter="stopEdit"
                                       @keyup.escape="cancelEdit"
                                       class="edit-input">
                                <span v-else>{{ item.row.Subscription }}</span>
                            </td>

                            <!-- VNet name - editable (colIndex 4) -->
                            <td class="px-2 py-2 font-medium editable-cell" :class="[getCellClass(item.row, 4, item.index), getCellBorderClass(item.row, 4, item.index), {'editing-cell': isEditing(item.index, 'VNet name')}]" @dblclick.stop="startEdit(item.index, 'VNet name', $event)">
                                <input v-if="isEditing(item.index, 'VNet name')"
                                       v-model="item.row['VNet name']"
                                       @blur="stopEdit"
                                       @keyup.enter="stopEdit"
                                       @keyup.escape="cancelEdit"
                                       class="edit-input">
                                <span v-else>{{ item.row['VNet name'] }}</span>
                            </td>

                            <!-- Subnet type - editable (colIndex 5) -->
                            <td class="px-2 py-2 editable-cell" :class="[getCellClass(item.row, 5, item.index), getCellBorderClass(item.row, 5, item.index), {'editing-cell': isEditing(item.index, 'Subnet type')}]" @dblclick.stop="startEdit(item.index, 'Subnet type', $event)">
                                <select v-if="isEditing(item.index, 'Subnet type')"
                                        v-model="item.row['Subnet type']"
                                        @blur="stopEdit"
                                        @change="stopEdit"
                                        class="edit-input">
                                    <option value="">-</option>
                                    <option value="isolated">isolated</option>
                                    <option value="common">common</option>
                                </select>
                                <span v-else>{{ item.row['Subnet type'] }}</span>
                            </td>

                            <!-- Start - editable (colIndex 6) -->
                            <td class="px-2 py-2 font-mono text-blue-700 editable-cell" :class="[getCellClass(item.row, 6, item.index), getCellBorderClass(item.row, 6, item.index), {'editing-cell': isEditing(item.index, 'Start')}]" @dblclick.stop="startEdit(item.index, 'Start', $event)">
                                <input v-if="isEditing(item.index, 'Start')"
                                       v-model="item.row.Start"
                                       @blur="onStartEdit(item.index)"
                                       @keyup.enter="onStartEdit(item.index)"
                                       @keyup.escape="cancelEdit"
                                       class="font-mono edit-input">
                                <span v-else>{{ item.row.Start }}</span>
                            </td>

                            <!-- Address space (colIndex 7) -->
                            <td class="px-2 py-2 font-mono text-xs text-green-700" :class="[getCellClass(item.row, 7, item.index), getCellBorderClass(item.row, 7, item.index)]" @dblclick.stop="highlightRowsInRange(item.index)">{{ item.row['Address space'] }}</td>

                            <!-- Subnet purpose - editable (colIndex 8) -->
                            <td class="px-2 py-2 editable-cell" :class="[getCellClass(item.row, 8, item.index), getCellBorderClass(item.row, 8, item.index), {'editing-cell': isEditing(item.index, 'Subnet purpose')}]" @dblclick.stop="startEdit(item.index, 'Subnet purpose', $event)">
                                <input v-if="isEditing(item.index, 'Subnet purpose')"
                                       v-model="item.row['Subnet purpose']"
                                       @blur="onPurposeEdit(item.index)"
                                       @keyup.enter="onPurposeEdit(item.index)"
                                       @keyup.escape="cancelEdit"
                                       class="edit-input">
                                <span v-else>{{ item.row['Subnet purpose'] }}</span>
                            </td>

                            <!-- Subnet name (colIndex 9) -->
                            <td class="px-2 py-2 font-mono text-xs" :class="[getCellClass(item.row, 9, item.index), getCellBorderClass(item.row, 9, item.index)]">{{ item.row['Subnet name'] }}</td>

                            <!-- Available addresses (colIndex 10) -->
                            <td class="px-2 py-2 text-right" :class="[getCellClass(item.row, 10, item.index), getCellBorderClass(item.row, 10, item.index)]">{{ item.row['Available addresses'] }}</td>

                            <!-- Comments - editable (colIndex 11) -->
                            <td class="px-2 py-2 text-gray-600 italic text-xs editable-cell" :class="[getCellClass(item.row, 11, item.index), getCellBorderClass(item.row, 11, item.index), {'editing-cell': isEditing(item.index, 'Comments')}]" @dblclick.stop="startEdit(item.index, 'Comments', $event)">
                                <input v-if="isEditing(item.index, 'Comments')"
                                       v-model="item.row.Comments"
                                       @blur="stopEdit"
                                       @keyup.enter="stopEdit"
                                       @keyup.escape="cancelEdit"
                                       class="edit-input">
                                <span v-else>{{ item.row.Comments }}</span>
                            </td>

                            <!-- Actions (colIndex 12) -->
                            <td class="px-2 py-2 whitespace-nowrap text-center bg-white" :class="getCellBorderClass(item.row, 12, item.index)">
                                <div v-if="item.row._pending" class="flex items-center justify-center gap-1 text-[10px] text-gray-600">
                                    <span>Ulozit?</span>
                                    <button @click.stop="confirmPendingRow(item.index, true)" class="action-btn ok" title="Ulozit">✓</button>
                                    <button @click.stop="confirmPendingRow(item.index, false)" class="action-btn cancel" title="Zrusit">×</button>
                                </div>
                                <div v-else class="flex justify-center">
                                    <button @click.stop="moveRowUp(item.index)" class="action-btn up" title="Presunout nahoru" :disabled="item.index === 0">&#9650;</button>
                                    <button @click.stop="moveRowDown(item.index)" class="action-btn down" title="Presunout dolu" :disabled="item.index === csvData.length - 1">&#9660;</button>
                                    <button @click.stop="addSubnetAfter(item.index)" class="action-btn add" title="Pridat radek za">+</button>
                                    <button @click.stop="duplicateRow(item.index)" class="action-btn dup" title="Duplikovat">D</button>
                                    <button @click.stop="deleteRow(item.index)" class="action-btn del" title="Smazat">X</button>
                                </div>
                            </td>
                        </tr>
                    </tbody>
                </table>
                </div>
            </div>

            <!-- Edit hint -->
            <div class="mt-2 text-center text-xs text-gray-400">
                Dvojklik = editace | Enter = potvrdit | Escape = zrusit
            </div>
        </div>

        <!-- Side Panel for Errors/Warnings/Gaps -->
        <div class="side-panel" :class="{ 'open': sidePanelOpen }" v-if="csvData.length">
            <div class="flex items-center justify-between mb-4">
                <h3 class="font-bold text-gray-800">Problemy & Free space</h3>
                <button @click="sidePanelOpen = false" class="text-gray-400 hover:text-gray-600 text-xl">&times;</button>
            </div>

            <!-- Errors -->
            <div v-if="errors.length" class="panel panel-error mb-3">
                <h4 class="font-semibold text-red-700 text-sm mb-2">Chyby ({{ errorRows.size }} radku)</h4>
                <ul class="space-y-1 text-xs max-h-32 overflow-y-auto">
                    <li v-for="(error, index) in errors" :key="index"
                        class="text-red-600 cursor-pointer hover:bg-red-100 px-2 py-1 rounded"
                        @click="scrollToRow(error.row)">
                        <span v-if="error.row2" class="inline-flex gap-1">
                            <span @click.stop="scrollToRow(error.row)" class="underline hover:text-red-800">#{{ error.row }}</span>
                            <span>&amp;</span>
                            <span @click.stop="scrollToRow(error.row2)" class="underline hover:text-red-800">#{{ error.row2 }}</span>
                            <span>se prekryvaji</span>
                        </span>
                        <span v-else><strong>#{{ error.row }}:</strong> {{ error.message }}</span>
                    </li>
                </ul>
            </div>

            <!-- Warnings -->
            <div v-if="warnings.length" class="panel panel-warning mb-3">
                <h4 class="font-semibold text-yellow-700 text-sm mb-2">Varovani ({{ warnings.length }})</h4>
                <ul class="space-y-1 text-xs max-h-32 overflow-y-auto">
                    <li v-for="(warning, index) in warnings" :key="index"
                        class="text-yellow-600 cursor-pointer hover:bg-yellow-100 px-2 py-1 rounded"
                        @click="scrollToRow(warning.row); sidePanelOpen = false">
                        <strong>{{ warning.row }}:</strong> {{ warning.message }}
                    </li>
                </ul>
            </div>

            <!-- Gaps -->
            <div v-if="gaps.length" class="panel panel-info">
                <div class="flex items-center justify-between mb-2">
                    <h4 class="font-semibold text-blue-700 text-sm">Gaps ({{ gaps.length }})</h4>
                    <button @click="fillAllGaps" class="text-xs text-blue-600 hover:underline">Doplnit vse</button>
                </div>
                <p class="text-[11px] text-blue-700/80 mb-2">
                    Helper prohledava rozsahy od shora (Network segment → MG → Subscription → VNet) a hleda neobsazene IP bloky mezi podsitemi v dane urovni. Volne misto muze doplnit jako “&lt;scope&gt; free space”.
                </p>
                <div class="space-y-2 max-h-64 overflow-y-auto">
                    <div v-for="(gap, index) in gaps" :key="index" class="bg-white p-2 rounded border text-xs">
                        <div class="font-mono text-blue-700">{{ gap.start }} - {{ gap.end }}</div>
                        <div class="text-gray-500">{{ formatNumber(gap.size) }} adres | {{ gap.scopeLabel }} | radek {{ gap.afterRow }}</div>
                        <button @click="fillGap(gap)" class="mt-1 text-blue-600 hover:underline text-xs">Doplnit</button>
                    </div>
                </div>
            </div>

            <!-- No issues -->
            <div v-if="!errors.length && !warnings.length && !gaps.length" class="text-center py-8 text-gray-400">
                <svg class="w-12 h-12 mx-auto mb-2 text-green-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z"/>
                </svg>
                <p>Zadne problemy!</p>
            </div>
        </div>

        <!-- Add Subnet Modal -->
        <div v-if="showAddModal" class="fixed inset-0 modal-overlay flex items-center justify-center z-50" @click.self="showAddModal = false">
            <div class="modal-content p-5 max-w-xl w-full mx-4 max-h-[85vh] overflow-y-auto">
                <div class="flex items-center justify-between mb-4">
                    <h2 class="text-lg font-bold text-gray-800">Pridat radek za #{{ selectedRowIndex + 2 }}</h2>
                    <button @click="showAddModal = false" class="text-gray-400 hover:text-gray-600 text-xl">&times;</button>
                </div>

                <div class="grid grid-cols-2 gap-3 mb-3">
                    <div>
                        <label class="block text-xs font-medium text-gray-600 mb-1">Rozsah</label>
                        <input v-model="newSubnet.suggested" class="w-full p-2 border rounded font-mono text-sm" @input="updateNewSubnetFromSuggested" placeholder="10.0.0.0/24">
                    </div>
                    <div>
                        <label class="block text-xs font-medium text-gray-600 mb-1">Prefix</label>
                        <select v-model="newSubnet.prefix" @change="updateNewSubnet" class="w-full p-2 border rounded text-sm">
                            <option v-for="p in availablePrefixes" :key="p" :value="p">/{{ p }} ({{ formatNumber(calculateAvailableIPs(p)) }})</option>
                        </select>
                    </div>
                </div>

                <div class="grid grid-cols-2 gap-3 mb-3">
                    <div>
                        <label class="block text-xs font-medium text-gray-600 mb-1">Start</label>
                        <input v-model="newSubnet.start" readonly class="w-full p-2 border rounded bg-gray-50 font-mono text-sm text-gray-500">
                    </div>
                    <div>
                        <label class="block text-xs font-medium text-gray-600 mb-1">Address Space</label>
                        <input v-model="newSubnet.addressSpace" readonly class="w-full p-2 border rounded bg-gray-50 font-mono text-xs text-gray-500">
                    </div>
                </div>

                <div class="grid grid-cols-3 gap-3 mb-3">
                    <div>
                        <label class="block text-xs font-medium text-gray-600 mb-1">Type</label>
                        <select v-model="newSubnet.type" class="w-full p-2 border rounded text-sm">
                            <option value="">-</option>
                            <option value="isolated">isolated</option>
                            <option value="common">common</option>
                        </select>
                    </div>
                    <div>
                        <label class="block text-xs font-medium text-gray-600 mb-1">Purpose</label>
                        <input v-model="newSubnet.purpose" @input="updateSubnetName" class="w-full p-2 border rounded text-sm" placeholder="web, db...">
                    </div>
                    <div>
                        <label class="block text-xs font-medium text-gray-600 mb-1">Comments</label>
                        <input v-model="newSubnet.comments" class="w-full p-2 border rounded text-sm" placeholder="...">
                    </div>
                </div>

                <div class="grid grid-cols-2 gap-3 mb-4">
                    <div>
                        <label class="block text-xs font-medium text-gray-600 mb-1">Name (auto)</label>
                        <input v-model="newSubnet.name" readonly class="w-full p-2 border rounded bg-gray-50 font-mono text-xs text-gray-500">
                    </div>
                    <div>
                        <label class="block text-xs font-medium text-gray-600 mb-1">Avail IPs</label>
                        <input v-model="newSubnet.available" readonly class="w-full p-2 border rounded bg-gray-50 text-sm text-gray-500">
                    </div>
                </div>

                <div class="flex justify-end gap-2 pt-3 border-t">
                    <button @click="showAddModal = false" class="btn btn-gray">Zrusit</button>
                    <button @click="confirmAddSubnet" class="btn btn-primary">Pridat</button>
                </div>
            </div>
        </div>

        <!-- CSV Columns Modal -->
        <div v-if="showCsvColumnsModal" class="fixed inset-0 modal-overlay flex items-center justify-center z-50" @click.self="showCsvColumnsModal = false">
            <div class="modal-content p-5 max-w-xl w-full mx-4 max-h-[85vh] overflow-y-auto">
                <div class="flex items-center justify-between mb-3">
                    <h2 class="text-lg font-bold text-gray-800">Nezname sloupce v CSV</h2>
                    <button @click="showCsvColumnsModal = false" class="text-gray-400 hover:text-gray-600 text-xl">&times;</button>
                </div>
                <p class="text-sm text-gray-600 mb-3">
                    Nalezeny sloupce, ktere neumi aplikace priradit. Vyberte, co s nimi udelat.
                </p>
                <div class="bg-gray-50 border rounded p-3 text-xs text-gray-700 mb-4">
                    <div class="font-semibold mb-1">Nezname sloupce:</div>
                    <div class="flex flex-wrap gap-2">
                        <span v-for="h in csvExtraHeaders" :key="h" class="px-2 py-1 bg-white border rounded">{{ h }}</span>
                    </div>
                </div>
                <div class="flex justify-end gap-2 pt-2 border-t">
                    <button @click="applyCsvExtraAction('drop')" class="btn btn-gray">Zahodit</button>
                    <button @click="applyCsvExtraAction('comments')" class="btn btn-primary">Pridat do Comments</button>
                </div>
            </div>
        </div>

        <!-- Subnet Naming Pattern Modal -->
        <div v-if="showNamingModal" class="fixed inset-0 modal-overlay flex items-center justify-center z-50" @click.self="showNamingModal = false">
            <div class="modal-content p-5 max-w-lg w-full mx-4 max-h-[85vh] overflow-y-auto">
                <div class="flex items-center justify-between mb-4">
                    <h2 class="text-lg font-bold text-gray-800">Vzor nazvu subnetu</h2>
                    <button @click="showNamingModal = false" class="text-gray-400 hover:text-gray-600 text-xl">&times;</button>
                </div>

                <div class="mb-4">
                    <label class="block text-sm font-medium text-gray-700 mb-2">Vzor pro generovani nazvu:</label>
                    <input v-model="subnetNamingPattern" class="w-full p-3 border rounded font-mono text-sm" placeholder="{purpose}-subnet-{region}-{start}">
                </div>

                <div class="mb-4 bg-gray-50 border rounded p-3">
                    <div class="text-xs font-semibold text-gray-600 mb-2">Dostupne promenne:</div>
                    <div class="grid grid-cols-2 gap-2 text-xs">
                        <div v-for="v in namingPatternVariables" :key="v.name" class="flex items-center gap-2">
                            <code class="px-2 py-1 bg-blue-100 text-blue-800 rounded cursor-pointer hover:bg-blue-200" @click="subnetNamingPattern += v.name">{{ v.name }}</code>
                            <span class="text-gray-500">{{ v.desc }}</span>
                        </div>
                    </div>
                </div>

                <div class="mb-4 bg-green-50 border border-green-200 rounded p-3">
                    <div class="text-xs font-semibold text-green-700 mb-1">Nahled:</div>
                    <div class="font-mono text-sm text-green-800">{{ previewSubnetName }}</div>
                </div>

                <div class="flex justify-end gap-2 pt-3 border-t">
                    <button @click="showNamingModal = false" class="btn btn-gray">Zavrit</button>
                    <button @click="applyNamingPatternToAll" class="btn btn-primary">Aplikovat na vsechny subnety</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        const { createApp, nextTick } = Vue;

        createApp({
            data() {
                return {
                    csvData: [],
                    errors: [],
                    warnings: [],
                    gaps: [],
                    freeSpaceFilter: {
                        networkSegment: true,
                        managementGroup: true,
                        subscription: true,
                        vnet: true
                    },
                    showFilters: false,
                    tableFilter: {
                        segment: '',
                        managementGroup: '',
                        subscription: '',
                        vnet: ''
                    },
                    highlightedRows: new Set(),
                    autoFixNotice: '',
                    errorRows: new Set(),
                    warningRows: new Set(),
                    showAddModal: false,
                    showCsvColumnsModal: false,
                    csvExtraHeaders: [],
                    csvPendingRows: [],
                    csvPendingExtras: [],
                    selectedRowIndex: -1,
                    editingCell: null,
                    editOriginalValue: '',
                    editOriginalNetwork: null,
                    dragOver: false,
                    lastValidation: '',
                    sidePanelOpen: false,
                    newSubnet: {
                        suggested: '',
                        prefix: 24,
                        start: '',
                        addressSpace: '',
                        type: '',
                        purpose: '',
                        name: '',
                        available: '',
                        comments: ''
                    },
                    availablePrefixes: [16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30],
                    segmentGroups: [],
                    mgGroups: [],
                    subscriptionGroups: [],
                    vnetGroups: [],
                    // Subnet naming pattern
                    showNamingModal: false,
                    subnetNamingPattern: '{purpose}-subnet-{region}-{start}',
                    namingPatternVariables: [
                        { name: '{purpose}', desc: 'Subnet purpose' },
                        { name: '{region}', desc: 'Region (zkratka z nazvu)' },
                        { name: '{start}', desc: 'IP rozsah (/ → -)' },
                        { name: '{vnet}', desc: 'VNet name' },
                        { name: '{subscription}', desc: 'Subscription' },
                        { name: '{mg}', desc: 'Management Group' },
                        { name: '{segment}', desc: 'Network segment' }
                    ]
                }
            },
            computed: {
                totalSubnets() {
                    return this.csvData.filter(row => this.getRowLevel(row) === 'subnet').length;
                },
                totalFreeSpace() {
                    return this.csvData.filter(row => this.getRowLevel(row) === 'free-space').length;
                },
                hasIssues() {
                    return this.errorRows.size > 0 || this.warnings.length > 0 || this.gaps.length > 0;
                },
                previewSubnetName() {
                    // Generate preview using sample data
                    const sampleRow = {
                        'Region': 'West Europe (WE)',
                        'Network segment': 'Production',
                        'Management Group': 'Platform',
                        'Subscription': 'Connectivity',
                        'VNet name': 'vnet-hub-we',
                        'Subnet purpose': 'external',
                        'Start': '10.104.0.0/28'
                    };
                    return this.generateSubnetName(sampleRow, this.subnetNamingPattern);
                },
                tableFilterOptions() {
                    const unique = (getter) => {
                        const set = new Set();
                        this.csvData.forEach(row => {
                            const value = (getter(row) || '').trim();
                            if (value) set.add(value);
                        });
                        return Array.from(set).sort((a, b) => a.localeCompare(b));
                    };

                    return {
                        segment: unique(row => row['Network segment']),
                        managementGroup: unique(row => row['Management Group']),
                        subscription: unique(row => row.Subscription),
                        vnet: unique(row => row['VNet name'])
                    };
                },
                filteredRows() {
                    const selection = this.getActiveScopeSelection();
                    const scopeNet = selection ? this.findScopeNet(selection.level, selection.value) : null;

                    return this.csvData
                        .map((row, index) => ({ row, index }))
                        .filter(({ row }) => this.rowMatchesScope(row, selection, scopeNet));
                }
            },
            methods: {
                getActiveScopeSelection() {
                    const vnet = (this.tableFilter.vnet || '').trim();
                    const sub = (this.tableFilter.subscription || '').trim();
                    const mg = (this.tableFilter.managementGroup || '').trim();
                    const seg = (this.tableFilter.segment || '').trim();

                    if (vnet) return { level: 'vnet', value: vnet };
                    if (sub) return { level: 'subscription', value: sub };
                    if (mg) return { level: 'management-group', value: mg };
                    if (seg) return { level: 'network-segment', value: seg };
                    return null;
                },

                findScopeNet(level, value) {
                    for (const row of this.csvData) {
                        if (!row.Start || !row.Start.includes('/')) continue;
                        if (this.getRowLevel(row) !== level) continue;

                        if (level === 'vnet' && (row['VNet name'] || '').trim() !== value) continue;
                        if (level === 'subscription' && (row.Subscription || '').trim() !== value) continue;
                        if (level === 'management-group' && (row['Management Group'] || '').trim() !== value) continue;
                        if (level === 'network-segment' && (row['Network segment'] || '').trim() !== value) continue;

                        try {
                            return this.parseNetwork(row.Start);
                        } catch (e) {
                            return null;
                        }
                    }

                    return null;
                },

                rowMatchesScope(row, selection, scopeNet) {
                    if (!selection || !scopeNet) {
                        return true;
                    }

                    // Rows without Start: include only if they match the selected scope value
                    if (!row.Start || !row.Start.includes('/')) {
                        if (selection.level === 'vnet') {
                            return (row['VNet name'] || '').trim() === selection.value;
                        }
                        if (selection.level === 'subscription') {
                            return (row.Subscription || '').trim() === selection.value;
                        }
                        if (selection.level === 'management-group') {
                            return (row['Management Group'] || '').trim() === selection.value;
                        }
                        if (selection.level === 'network-segment') {
                            return (row['Network segment'] || '').trim() === selection.value;
                        }
                        return false;
                    }

                    try {
                        const net = this.parseNetwork(row.Start);

                        const isInside = net.numericStart >= scopeNet.numericStart &&
                                         net.numericEnd <= scopeNet.numericEnd;
                        const isParent = net.numericStart <= scopeNet.numericStart &&
                                         net.numericEnd >= scopeNet.numericEnd;

                        return isInside || isParent;
                    } catch (e) {
                        return false;
                    }
                },
                handleFileDrop(e) {
                    this.dragOver = false;
                    const file = e.dataTransfer.files[0];
                    this.loadFile(file);
                },
                highlightRowsInRange(index) {
                    const row = this.csvData[index];
                    if (!row || !row.Start || !row.Start.includes('/')) return;

                    let scopeNet;
                    try {
                        scopeNet = this.parseNetwork(row.Start);
                    } catch (e) {
                        return;
                    }

                    this.highlightedRows = new Set();
                    this.csvData.forEach((r, i) => {
                        if (!r.Start || !r.Start.includes('/')) return;
                        try {
                            const net = this.parseNetwork(r.Start);
                            if (net.numericStart >= scopeNet.numericStart && net.numericEnd <= scopeNet.numericEnd) {
                                this.highlightedRows.add(i);
                            }
                        } catch (e) {
                            // ignore invalid
                        }
                    });

                    setTimeout(() => {
                        this.highlightedRows = new Set();
                    }, 2000);
                },
                handleFileSelect(e) {
                    const file = e.target.files[0];
                    this.loadFile(file);
                },
                loadFile(file) {
                    if (!file || !file.name.endsWith('.csv')) {
                        alert('Prosim vyberte CSV soubor');
                        return;
                    }

                    const reader = new FileReader();
                    reader.onload = (e) => {
                        this.parseCSV(e.target.result);
                        this.validateAll();
                        this.detectGaps();
                    };
                    reader.readAsText(file, 'UTF-8');
                },
                parseCSV(text) {
                    const lines = text.split('\n');
                    const headers = lines[0].split(';').map(h => h.trim().replace(/^\uFEFF/, ''));
                    const expectedHeaders = [
                        'Region',
                        'Network segment',
                        'Management Group',
                        'Subscription',
                        'VNet name',
                        'Subnet type',
                        'Start',
                        'Address space',
                        'Subnet purpose',
                        'Subnet name',
                        'Available addresses',
                        'Comments'
                    ];

                    const mgHeaders = headers.filter(h => h.toLowerCase().includes('management group'));
                    const purposeHeaders = headers.filter(h => h.toLowerCase().includes('purpose'));
                    const extraHeaders = headers.filter(h =>
                        h &&
                        !expectedHeaders.includes(h) &&
                        !mgHeaders.includes(h) &&
                        !purposeHeaders.includes(h)
                    );

                    const baseRows = [];
                    const extrasRows = [];

                    for (let i = 1; i < lines.length; i++) {
                        if (!lines[i].trim()) continue;

                        const values = lines[i].split(';');
                        const row = {};
                        expectedHeaders.forEach(h => {
                            row[h] = '';
                        });

                        let mgValues = [];
                        let purposeValues = [];
                        headers.forEach((header, idx) => {
                            const value = values[idx] ? values[idx].trim() : '';

                            if (mgHeaders.includes(header)) {
                                if (value) mgValues.push(value);
                                return;
                            }

                            if (purposeHeaders.includes(header) && header !== 'Subnet purpose') {
                                if (value) purposeValues.push(value);
                                return;
                            }

                            if (expectedHeaders.includes(header)) {
                                row[header] = value;
                            }
                        });

                        if (mgValues.length) {
                            row['Management Group'] = mgValues.join('; ');
                        }
                        if (purposeValues.length) {
                            if (row['Subnet purpose']) {
                                row['Subnet purpose'] = `${row['Subnet purpose']}; ${purposeValues.join('; ')}`;
                            } else {
                                row['Subnet purpose'] = purposeValues.join('; ');
                            }
                        }

                        const extras = [];
                        headers.forEach((header, idx) => {
                            if (!extraHeaders.includes(header)) return;
                            const value = values[idx] ? values[idx].trim() : '';
                            if (value) extras.push(value);
                        });

                        baseRows.push(row);
                        extrasRows.push(extras);
                    }

                    if (extraHeaders.length) {
                        this.csvExtraHeaders = extraHeaders;
                        this.csvPendingRows = baseRows;
                        this.csvPendingExtras = extrasRows;
                        this.showCsvColumnsModal = true;
                        return;
                    }

                    this.csvData = baseRows;
                    this.calculateGroups();
                },
                applyCsvExtraAction(action) {
                    const rows = this.csvPendingRows || [];
                    const extrasRows = this.csvPendingExtras || [];

                    if (action === 'comments') {
                        rows.forEach((row, idx) => {
                            const extras = extrasRows[idx] || [];
                            if (!extras.length) return;
                            const extraText = extras.join('; ');
                            if (row.Comments) {
                                row.Comments = `${row.Comments}; ${extraText}`;
                            } else {
                                row.Comments = extraText;
                            }
                        });
                    }

                    this.csvData = rows;
                    this.csvExtraHeaders = [];
                    this.csvPendingRows = [];
                    this.csvPendingExtras = [];
                    this.showCsvColumnsModal = false;
                    this.calculateGroups();
                    this.validateAll();
                    this.detectGaps();
                },
                calculateGroups() {
                    this.segmentGroups = [];
                    this.mgGroups = [];
                    this.subscriptionGroups = [];
                    this.vnetGroups = [];

                    // Find Network Segment groups based on IP ranges
                    let i = 0;
                    while (i < this.csvData.length) {
                        const row = this.csvData[i];
                        const segment = row['Network segment'] && row['Network segment'].trim();
                        const segStart = row.Start;
                        const level = this.getRowLevel(row);

                        if (segment && segStart && segStart.includes('/') && level === 'network-segment') {
                            try {
                                const segNet = this.parseNetwork(segStart);
                                const groupStart = i;
                                let groupEnd = i;

                                for (let j = i + 1; j < this.csvData.length; j++) {
                                    const nextRow = this.csvData[j];
                                    const nextStart = nextRow.Start;
                                    const nextLevel = this.getRowLevel(nextRow);

                                    if (nextLevel === 'network-segment' || nextLevel === 'region') {
                                        break;
                                    }

                                    if (nextStart && nextStart.includes('/')) {
                                        try {
                                            const nextNet = this.parseNetwork(nextStart);
                                            if (nextNet.numericStart >= segNet.numericStart &&
                                                nextNet.numericEnd <= segNet.numericEnd) {
                                                groupEnd = j;
                                            } else {
                                                break;
                                            }
                                        } catch (e) {}
                                    }
                                }

                                this.segmentGroups.push({
                                    start: groupStart,
                                    end: groupEnd,
                                    name: segment,
                                    range: segNet
                                });

                                i = groupEnd + 1;
                                continue;
                            } catch (e) {}
                        }
                        i++;
                    }

                    // Find Management Group groups based on IP ranges
                    i = 0;
                    while (i < this.csvData.length) {
                        const row = this.csvData[i];
                        const mg = row['Management Group'] && row['Management Group'].trim();
                        const mgStart = row.Start;
                        const level = this.getRowLevel(row);

                        if (mg && mgStart && mgStart.includes('/') && level === 'management-group') {
                            try {
                                const mgNet = this.parseNetwork(mgStart);
                                const groupStart = i;
                                let groupEnd = i;

                                for (let j = i + 1; j < this.csvData.length; j++) {
                                    const nextRow = this.csvData[j];
                                    const nextStart = nextRow.Start;
                                    const nextLevel = this.getRowLevel(nextRow);

                                    if (nextLevel === 'management-group' || nextLevel === 'network-segment' || nextLevel === 'region') {
                                        break;
                                    }

                                    if (nextStart && nextStart.includes('/')) {
                                        try {
                                            const nextNet = this.parseNetwork(nextStart);
                                            if (nextNet.numericStart >= mgNet.numericStart &&
                                                nextNet.numericEnd <= mgNet.numericEnd) {
                                                groupEnd = j;
                                            } else {
                                                break;
                                            }
                                        } catch (e) {}
                                    }
                                }

                                this.mgGroups.push({
                                    start: groupStart,
                                    end: groupEnd,
                                    name: mg,
                                    range: mgNet
                                });

                                i = groupEnd + 1;
                                continue;
                            } catch (e) {}
                        }
                        i++;
                    }

                    // Find VNet groups based on IP ranges
                    i = 0;
                    while (i < this.csvData.length) {
                        const row = this.csvData[i];
                        const vnet = row['VNet name'] && row['VNet name'].trim();
                        const vnetStart = row.Start;

                        if (vnet && vnetStart && vnetStart.includes('/')) {
                            // Found a VNet with IP range
                            try {
                                const vnetNet = this.parseNetwork(vnetStart);
                                const groupStart = i;
                                let groupEnd = i;

                                // Find all following rows that fall within this VNet's IP range
                                for (let j = i + 1; j < this.csvData.length; j++) {
                                    const nextRow = this.csvData[j];
                                    const nextVnet = nextRow['VNet name'] && nextRow['VNet name'].trim();
                                    const nextStart = nextRow.Start;

                                    // Stop if we hit another VNet definition
                                    if (nextVnet) break;

                                    // Check if this row's IP falls within VNet range
                                    if (nextStart && nextStart.includes('/')) {
                                        try {
                                            const nextNet = this.parseNetwork(nextStart);
                                            // Check if subnet is within VNet range
                                            if (nextNet.numericStart >= vnetNet.numericStart &&
                                                nextNet.numericEnd <= vnetNet.numericEnd) {
                                                groupEnd = j;
                                            } else {
                                                // IP is outside VNet range, stop
                                                break;
                                            }
                                        } catch (e) {
                                            // Invalid IP, skip
                                        }
                                    } else {
                                        // Row without IP, check if it's a higher level
                                        const level = this.getRowLevel(nextRow);
                                        if (level === 'subscription' || level === 'management-group' ||
                                            level === 'network-segment' || level === 'region') {
                                            break;
                                        }
                                    }
                                }

                                this.vnetGroups.push({
                                    start: groupStart,
                                    end: groupEnd,
                                    name: vnet,
                                    range: vnetNet
                                });

                                i = groupEnd + 1;
                                continue;
                            } catch (e) {
                                // Invalid VNet IP, skip
                            }
                        }
                        i++;
                    }

                    // Find Subscription groups based on IP ranges
                    i = 0;
                    while (i < this.csvData.length) {
                        const row = this.csvData[i];
                        const subscription = row.Subscription && row.Subscription.trim();
                        const subStart = row.Start;
                        const level = this.getRowLevel(row);

                        // Create subscription group for subscription-level rows
                        if (subscription && subStart && subStart.includes('/') && level === 'subscription') {
                            try {
                                const subNet = this.parseNetwork(subStart);
                                const groupStart = i;
                                let groupEnd = i;

                                // Find all following rows that fall within this Subscription's IP range
                                for (let j = i + 1; j < this.csvData.length; j++) {
                                    const nextRow = this.csvData[j];
                                    const nextStart = nextRow.Start;
                                    const nextLevel = this.getRowLevel(nextRow);

                                    // Stop if we hit another Subscription definition or higher level
                                    if (nextLevel === 'subscription' || nextLevel === 'management-group' ||
                                        nextLevel === 'network-segment' || nextLevel === 'region') {
                                        break;
                                    }

                                    // Check if this row's IP falls within Subscription range
                                    if (nextStart && nextStart.includes('/')) {
                                        try {
                                            const nextNet = this.parseNetwork(nextStart);
                                            if (nextNet.numericStart >= subNet.numericStart &&
                                                nextNet.numericEnd <= subNet.numericEnd) {
                                                groupEnd = j;
                                            } else {
                                                break;
                                            }
                                        } catch (e) {
                                            // Invalid IP
                                        }
                                    }
                                }

                                this.subscriptionGroups.push({
                                    start: groupStart,
                                    end: groupEnd,
                                    name: subscription,
                                    range: subNet
                                });

                                i = groupEnd + 1;
                                continue;
                            } catch (e) {
                                // Invalid IP
                            }
                        }
                        i++;
                    }
                },

                // Determine the hierarchy level of a row
                getRowLevel(row) {
                    const hasRegion = row.Region && row.Region.trim();
                    const hasSegment = row['Network segment'] && row['Network segment'].trim();
                    const hasMG = row['Management Group'] && row['Management Group'].trim();
                    const hasSubscription = row.Subscription && row.Subscription.trim();
                    const hasVNet = row['VNet name'] && row['VNet name'].trim();
                    const hasSubnetType = row['Subnet type'] && row['Subnet type'].trim();
                    const hasSubnetPurpose = row['Subnet purpose'] && row['Subnet purpose'].trim();
                    const name = (row['Subnet name'] || '').toLowerCase();
                    const comments = (row.Comments || '').toLowerCase();

                    // Check for free space indicators in name (preferred) or comments (legacy)
                    const isFreeSpace = name.includes('free space') ||
                                       name.includes('free scope') ||
                                       name.includes('freespace') ||
                                       comments.includes('free space') ||
                                       comments.includes('free scope') ||
                                       comments.includes('freespace');

                    // Determine level based on what's filled and what's NOT filled
                    // Key insight: level is determined by the LAST filled column in hierarchy

                    // If has subnet type OR subnet purpose (and not free space) -> actual subnet
                    if ((hasSubnetType || hasSubnetPurpose) && !isFreeSpace) {
                        return 'subnet';
                    }

                    // If name/comments indicate free space
                    if (isFreeSpace) {
                        return 'free-space';
                    }

                    // If has VNet but no subnet type/purpose -> VNet level
                    if (hasVNet && !hasSubnetType && !hasSubnetPurpose) {
                        return 'vnet';
                    }

                    // If has Subscription but no VNet -> Subscription level
                    if (hasSubscription && !hasVNet) {
                        return 'subscription';
                    }

                    // If has MG but no Subscription -> MG level
                    if (hasMG && !hasSubscription) {
                        return 'management-group';
                    }

                    // If has Segment but no MG -> Segment level
                    if (hasSegment && !hasMG) {
                        return 'network-segment';
                    }

                    // If has only Region -> Region level
                    if (hasRegion && !hasSegment) {
                        return 'region';
                    }

                    // Default - if we can't determine, check if it looks like a summary row
                    // (has CIDR but missing lower-level identifiers)
                    if (row.Start && row.Start.includes('/')) {
                        if (!hasVNet && !hasSubnetType && !hasSubnetPurpose) {
                            // It's some kind of allocation/summary row
                            if (hasSubscription) return 'subscription';
                            if (hasMG) return 'management-group';
                            if (hasSegment) return 'network-segment';
                            if (hasRegion) return 'region';
                        }
                    }

                    return 'subnet'; // fallback
                },

                validateAll() {
                    this.errors = [];
                    this.warnings = [];
                    this.errorRows = new Set();
                    this.warningRows = new Set();
                    this.autoFixNotice = '';
                    let autoFixed = 0;
                    let askedAutoFix = false;
                    let allowAutoFix = false;

                    const azureSpecial = ['AzureBastionSubnet', 'GatewaySubnet', 'RouterServerSubnet', 'AzureFirewallSubnet', 'AzureFirewallManagementSubnet'];
                    const networks = [];

                    this.csvData.forEach((row, idx) => {
                        const subnet = row.Start;
                        const purpose = row['Subnet purpose'];
                        const name = row['Subnet name'];
                        const level = this.getRowLevel(row);

                        if (!subnet || !subnet.includes('/')) return;

                        // Validate CIDR format
                        try {
                            const net = this.parseNetwork(subnet);
                            networks.push({ idx: idx + 2, subnet, net, level });

                            // Check if IP is the correct network address (first IP of the range)
                            const enteredIP = subnet.split('/')[0];
                            const correctNetworkIP = this.numericToIP(net.numericStart);
                            if (enteredIP !== correctNetworkIP) {
                                this.errors.push({
                                    row: idx + 2,
                                    message: `Spatna sitova adresa '${subnet}' - spravne by melo byt '${correctNetworkIP}/${net.prefix}'`
                                });
                                this.errorRows.add(idx + 2);
                            }

                            const computedAddress = `${this.numericToIP(net.numericStart)} - ${this.numericToIP(net.numericEnd)}`;
                            if (row['Address space'] !== computedAddress) {
                                if (!askedAutoFix) {
                                    askedAutoFix = true;
                                    allowAutoFix = confirm('Nesedi Address space u nekterych radku. Chcete je automaticky opravit?');
                                }
                                if (allowAutoFix) {
                                    row['Address space'] = computedAddress;
                                    row['Available addresses'] = this.calculateAvailableIPs(net.prefix).toString();
                                    autoFixed += 1;
                                }
                            }
                        } catch (e) {
                            this.errors.push({ row: idx + 2, message: `Neplatny format IP '${subnet}'` });
                            this.errorRows.add(idx + 2);
                            return;
                        }

                        // Only validate naming for actual subnets (not allocations or free space)
                        if (level === 'subnet') {
                            // Validate naming convention using current pattern
                            if (purpose && !azureSpecial.includes(purpose)) {
                                const expected = this.generateSubnetName(row, this.subnetNamingPattern, idx);
                                if (name && expected && name !== expected) {
                                    this.warnings.push({ row: idx + 2, message: `Nazev '${name}' nesedi se vzorem. Ocekavano '${expected}'` });
                                    this.warningRows.add(idx + 2);
                                }
                            }

                            // Check if purpose is filled but name is empty
                            if (purpose && !name && !azureSpecial.includes(purpose)) {
                                this.warnings.push({ row: idx + 2, message: `Ucel vyplnen, ale nazev chybi` });
                                this.warningRows.add(idx + 2);
                            }
                        }
                    });

                    // Check overlaps - only between subnets at the same level (actual subnets)
                    const actualSubnets = networks.filter(n => n.level === 'subnet' || n.level === 'free-space');
                    for (let i = 0; i < actualSubnets.length; i++) {
                        for (let j = i + 1; j < actualSubnets.length; j++) {
                            const net1 = actualSubnets[i];
                            const net2 = actualSubnets[j];

                            if (this.networksOverlap(net1.net, net2.net)) {
                                // Add ONE error message for the overlap
                                this.errors.push({
                                    row: net1.idx,
                                    row2: net2.idx,
                                    message: `Radky ${net1.idx} a ${net2.idx} se prekryvaji (${net1.subnet} vs ${net2.subnet})`
                                });
                                // Mark BOTH rows as errors (both will be red)
                                this.errorRows.add(net1.idx);
                                this.errorRows.add(net2.idx);
                            }
                        }
                    }

                    // Check IP order - rows should be in ascending order by Start IP
                    let prevNet = null;
                    let prevIdx = null;
                    for (const net of networks) {
                        if (prevNet !== null) {
                            // Check if current IP is less than previous (wrong order)
                            if (net.net.numericStart < prevNet.numericStart) {
                                this.warnings.push({
                                    row: net.idx,
                                    message: `Spatne poradi - ${net.subnet} by mel byt pred radkem ${prevIdx} (${this.numericToIP(prevNet.numericStart)})`
                                });
                                this.warningRows.add(net.idx);
                            }
                        }
                        prevNet = net.net;
                        prevIdx = net.idx;
                    }

                    // Update last validation time
                    const now = new Date();
                    this.lastValidation = now.toLocaleTimeString('cs-CZ');
                    if (autoFixed > 0) {
                        this.autoFixNotice = `Automaticky opraveno ${autoFixed} radku (Address space a IPs).`;
                        setTimeout(() => {
                            this.autoFixNotice = '';
                        }, 2000);
                    }
                },

                getFreeSpaceScope(row) {
                    const name = (row['Subnet name'] || '').toLowerCase();
                    const comments = (row.Comments || '').toLowerCase();
                    if (name.includes('vnet free space')) return 'vnet';
                    if (name.includes('subscription free space')) return 'subscription';
                    if (name.includes('mg free space') || name.includes('management group free space')) return 'management-group';
                    if (name.includes('network segment free space') || name.includes('segment free space')) return 'network-segment';
                    if (comments.includes('vnet free space')) return 'vnet';
                    if (comments.includes('subscription free space')) return 'subscription';
                    if (comments.includes('mg free space') || comments.includes('management group free space')) return 'management-group';
                    if (comments.includes('network segment free space') || comments.includes('segment free space')) return 'network-segment';
                    return null;
                },

                setAllFreeSpaceFilters(value) {
                    this.freeSpaceFilter.networkSegment = value;
                    this.freeSpaceFilter.managementGroup = value;
                    this.freeSpaceFilter.subscription = value;
                    this.freeSpaceFilter.vnet = value;
                },
                // Find the largest CIDR block that starts at the given IP and fits within the gap
                findLargestAlignedBlock(startNumeric, endNumeric) {
                    const gapSize = endNumeric - startNumeric + 1;

                    // Try prefixes from largest (/16) to smallest (/32)
                    for (let prefix = 16; prefix <= 32; prefix++) {
                        const blockSize = Math.pow(2, 32 - prefix);
                        // Check if start is aligned to this block size
                        if ((startNumeric % blockSize) === 0) {
                            // Check if block fits within gap
                            if (blockSize <= gapSize) {
                                return { prefix, blockSize };
                            }
                        }
                    }
                    return { prefix: 32, blockSize: 1 };
                },

                // Split a gap into multiple properly aligned CIDR blocks
                splitGapIntoCIDRs(gapStartIP, gapEndIP) {
                    const blocks = [];
                    let cursor = this.parseNetwork(`${gapStartIP}/32`).numericStart;
                    const endNumeric = this.parseNetwork(`${gapEndIP}/32`).numericStart;

                    while (cursor <= endNumeric) {
                        const remaining = endNumeric - cursor + 1;
                        const { prefix, blockSize } = this.findLargestAlignedBlock(cursor, endNumeric);

                        const blockEnd = cursor + blockSize - 1;
                        blocks.push({
                            start: this.numericToIP(cursor),
                            end: this.numericToIP(blockEnd),
                            prefix: prefix,
                            size: blockSize
                        });

                        cursor = blockEnd + 1;

                        // Safety check to prevent infinite loops
                        if (blocks.length > 100) break;
                    }

                    return blocks;
                },

                selectGapPrefix(gapStart, gapEnd) {
                    const startNet = this.parseNetwork(`${gapStart}/32`);
                    const endNet = this.parseNetwork(`${gapEnd}/32`);
                    const gapSize = endNet.numericStart - startNet.numericStart + 1;

                    for (let prefix = 16; prefix <= 30; prefix++) {
                        const block = Math.pow(2, 32 - prefix);
                        if (block <= gapSize && (startNet.numericStart % block === 0)) {
                            return prefix;
                        }
                    }

                    for (let prefix = 30; prefix <= 32; prefix++) {
                        const block = Math.pow(2, 32 - prefix);
                        if (startNet.numericStart % block === 0) {
                            return prefix;
                        }
                    }

                    return 32;
                },
                buildGapNet(gap) {
                    const startNet = this.parseNetwork(`${gap.start}/32`);
                    const endNet = this.parseNetwork(`${gap.end}/32`);
                    const gapEndNumeric = endNet.numericStart;
                    let prefix = this.selectGapPrefix(gap.start, gap.end);

                    let net = this.parseNetwork(`${gap.start}/${prefix}`);
                    while (net.numericEnd > gapEndNumeric && prefix < 32) {
                        prefix += 1;
                        net = this.parseNetwork(`${gap.start}/${prefix}`);
                    }

                    return { net, prefix };
                },

                detectGaps() {
                    this.gaps = [];
                    const allNetworks = [];

                    this.csvData.forEach((row, idx) => {
                        if (!row.Start || !row.Start.includes('/')) return;
                        try {
                            const net = this.parseNetwork(row.Start);
                            const level = this.getRowLevel(row);
                            allNetworks.push({
                                idx: idx,
                                rowNum: idx + 2,
                                subnet: row.Start,
                                net: net,
                                row: row,
                                level: level,
                                freeScope: level === 'free-space' ? this.getFreeSpaceScope(row) : null
                            });
                        } catch (e) {
                            // Skip invalid CIDRs
                        }
                    });

                    const scopeLabel = {
                        'vnet': 'VNet',
                        'subscription': 'Subscription',
                        'management-group': 'MG',
                        'network-segment': 'Network segment'
                    };

                    const childPriority = {
                        'vnet': ['subnet'],
                        'subscription': ['vnet', 'subnet'],
                        'management-group': ['subscription', 'vnet', 'subnet'],
                        'network-segment': ['management-group', 'subscription', 'vnet', 'subnet']
                    };

                    const scopeLevels = ['network-segment', 'management-group', 'subscription', 'vnet'];

                    for (const scopeLevel of scopeLevels) {
                        if (scopeLevel === 'network-segment' && !this.freeSpaceFilter.networkSegment) continue;
                        if (scopeLevel === 'management-group' && !this.freeSpaceFilter.managementGroup) continue;
                        if (scopeLevel === 'subscription' && !this.freeSpaceFilter.subscription) continue;
                        if (scopeLevel === 'vnet' && !this.freeSpaceFilter.vnet) continue;

                        const scopeRows = allNetworks.filter(n => n.level === scopeLevel);

                        for (const scopeRow of scopeRows) {
                            const scopeNet = scopeRow.net;

                            const inside = allNetworks.filter(n => n.idx !== scopeRow.idx &&
                                n.net.numericStart >= scopeNet.numericStart &&
                                n.net.numericEnd <= scopeNet.numericEnd);

                            let chosenLevel = null;
                            for (const candidateLevel of childPriority[scopeLevel]) {
                                if (inside.some(n => n.level === candidateLevel)) {
                                    chosenLevel = candidateLevel;
                                    break;
                                }
                            }

                            let candidates = [];
                            if (chosenLevel) {
                                candidates = inside.filter(n => n.level === chosenLevel);
                                const childFreeSpace = inside.filter(n => n.level === 'free-space' && n.freeScope === chosenLevel);
                                candidates = candidates.concat(childFreeSpace);
                            }

                            const freeSpaceCandidates = inside.filter(n => n.level === 'free-space' && n.freeScope === scopeLevel);
                            candidates = candidates.concat(freeSpaceCandidates);

                            // If no candidates, suggest full free space for the scope
                            if (candidates.length === 0) {
                                this.gaps.push({
                                    start: this.numericToIP(scopeNet.numericStart),
                                    end: this.numericToIP(scopeNet.numericEnd),
                                    size: scopeNet.numericEnd - scopeNet.numericStart + 1,
                                    after: scopeRow.subnet,
                                    afterIdx: scopeRow.idx,
                                    afterRow: scopeRow.rowNum,
                                    scopeType: scopeLevel,
                                    scopeLabel: scopeLabel[scopeLevel],
                                    context: scopeRow.row
                                });
                                continue;
                            }

                            candidates.sort((a, b) => a.net.numericStart - b.net.numericStart);

                            let cursor = scopeNet.numericStart;
                            let lastCandidate = null;

                            for (const cand of candidates) {
                                if (cand.net.numericStart > cursor) {
                                    const gapStart = cursor;
                                    const gapEnd = cand.net.numericStart - 1;
                                    this.gaps.push({
                                        start: this.numericToIP(gapStart),
                                        end: this.numericToIP(gapEnd),
                                        size: gapEnd - gapStart + 1,
                                        after: lastCandidate ? lastCandidate.subnet : scopeRow.subnet,
                                        afterIdx: lastCandidate ? lastCandidate.idx : scopeRow.idx,
                                        afterRow: lastCandidate ? lastCandidate.rowNum : scopeRow.rowNum,
                                        scopeType: scopeLevel,
                                        scopeLabel: scopeLabel[scopeLevel],
                                        context: scopeRow.row
                                    });
                                }

                                cursor = Math.max(cursor, cand.net.numericEnd + 1);
                                lastCandidate = cand;
                            }

                            if (cursor <= scopeNet.numericEnd) {
                                this.gaps.push({
                                    start: this.numericToIP(cursor),
                                    end: this.numericToIP(scopeNet.numericEnd),
                                    size: scopeNet.numericEnd - cursor + 1,
                                    after: lastCandidate ? lastCandidate.subnet : scopeRow.subnet,
                                    afterIdx: lastCandidate ? lastCandidate.idx : scopeRow.idx,
                                    afterRow: lastCandidate ? lastCandidate.rowNum : scopeRow.rowNum,
                                    scopeType: scopeLevel,
                                    scopeLabel: scopeLabel[scopeLevel],
                                    context: scopeRow.row
                                });
                            }
                        }
                    }
                },

                fillGap(gap) {
                    // Split gap into multiple properly aligned CIDR blocks
                    const blocks = this.splitGapIntoCIDRs(gap.start, gap.end);
                    const templateRow = gap.context;

                    // Insert blocks in reverse order to maintain correct indices
                    const insertIndex = gap.afterIdx + 1;
                    for (let i = blocks.length - 1; i >= 0; i--) {
                        const block = blocks[i];
                        const newRow = {
                            'Region': templateRow.Region || '',
                            'Network segment': templateRow['Network segment'] || '',
                            'Management Group': templateRow['Management Group'] || '',
                            'Subscription': templateRow.Subscription || '',
                            'VNet name': templateRow['VNet name'] || '',
                            'Subnet type': '',
                            'Start': `${block.start}/${block.prefix}`,
                            'Address space': `${block.start} - ${block.end}`,
                            'Subnet purpose': '',
                            'Subnet name': `${gap.scopeLabel} free space`,
                            'Available addresses': this.calculateAvailableIPs(block.prefix).toString(),
                            'Comments': '',
                            _pending: true
                        };
                        this.csvData.splice(insertIndex, 0, newRow);
                    }

                    this.calculateGroups();
                    this.validateAll();
                    this.detectGaps();
                },
                confirmPendingRow(index, keep) {
                    if (!keep) {
                        this.csvData.splice(index, 1);
                    } else {
                        if (this.csvData[index]) {
                            delete this.csvData[index]._pending;
                        }
                    }
                    this.calculateGroups();
                    this.validateAll();
                    this.detectGaps();
                },

                fillAllGaps() {
                    if (!confirm(`Opravdu chcete automaticky doplnit vsech ${this.gaps.length} mezer?`)) return;

                    // Sort gaps by index descending to preserve indices when inserting
                    const sortedGaps = [...this.gaps].sort((a, b) => b.afterIdx - a.afterIdx);

                    for (const gap of sortedGaps) {
                        // Split gap into multiple properly aligned CIDR blocks
                        const blocks = this.splitGapIntoCIDRs(gap.start, gap.end);
                        const templateRow = gap.context;
                        const insertIndex = gap.afterIdx + 1;

                        // Insert blocks in reverse order to maintain correct indices
                        for (let i = blocks.length - 1; i >= 0; i--) {
                            const block = blocks[i];
                            const newRow = {
                                'Region': templateRow.Region || '',
                                'Network segment': templateRow['Network segment'] || '',
                                'Management Group': templateRow['Management Group'] || '',
                                'Subscription': templateRow.Subscription || '',
                                'VNet name': templateRow['VNet name'] || '',
                                'Subnet type': '',
                                'Start': `${block.start}/${block.prefix}`,
                                'Address space': `${block.start} - ${block.end}`,
                                'Subnet purpose': '',
                                'Subnet name': `${gap.scopeLabel} free space`,
                                'Available addresses': this.calculateAvailableIPs(block.prefix).toString(),
                                'Comments': ''
                            };
                            this.csvData.splice(insertIndex, 0, newRow);
                        }
                    }

                    this.calculateGroups();
                    this.validateAll();
                    this.detectGaps();
                },

                // Editing functionality
                isEditing(rowIndex, column) {
                    return this.editingCell &&
                           this.editingCell.row === rowIndex &&
                           this.editingCell.column === column;
                },

                startEdit(rowIndex, column, event) {
                    this.editingCell = { row: rowIndex, column: column };
                    this.editOriginalValue = this.csvData[rowIndex][column];

                    // Store old network info when editing Start column for cascading updates
                    if (column === 'Start') {
                        const oldStart = this.csvData[rowIndex].Start;
                        if (oldStart && oldStart.includes('/')) {
                            try {
                                this.editOriginalNetwork = this.parseNetwork(oldStart);
                            } catch (e) {
                                this.editOriginalNetwork = null;
                            }
                        } else {
                            this.editOriginalNetwork = null;
                        }
                    }

                    // Use setTimeout to wait for Vue to render the input
                    setTimeout(() => {
                        const td = event ? event.currentTarget : null;
                        if (td) {
                            const input = td.querySelector('.edit-input');
                            if (input) {
                                input.focus();
                                if (input.select) input.select();
                            }
                        }
                    }, 10);
                },

                stopEdit() {
                    if (this.editingCell) {
                        this.editingCell = null;
                        this.calculateGroups();
                    }
                },

                cancelEdit() {
                    if (this.editingCell) {
                        this.csvData[this.editingCell.row][this.editingCell.column] = this.editOriginalValue;
                        this.editingCell = null;
                    }
                },

                onStartEdit(index) {
                    const row = this.csvData[index];
                    const newStart = row.Start;
                    const oldNetwork = this.editOriginalNetwork;

                    this.stopEdit();

                    // Check if we should cascade changes to child rows
                    if (oldNetwork && newStart && newStart.includes('/')) {
                        try {
                            const newNetwork = this.parseNetwork(newStart);

                            // Only cascade if the network actually changed
                            if (oldNetwork.numericStart !== newNetwork.numericStart) {
                                this.cascadeIPChanges(index, oldNetwork, newNetwork);
                            }
                        } catch (e) {
                            // Invalid new CIDR, just recalculate this row
                        }
                    }

                    this.editOriginalNetwork = null;
                    this.recalculateRow(index);
                    this.validateAll();
                    this.detectGaps();
                },

                // Cascade IP changes to all child rows within the old range
                cascadeIPChanges(parentIndex, oldNetwork, newNetwork) {
                    const offset = newNetwork.numericStart - oldNetwork.numericStart;
                    const childRows = [];

                    // Find all rows whose IP falls strictly within the old parent range (excluding parent itself)
                    this.csvData.forEach((row, idx) => {
                        if (idx === parentIndex) return;
                        if (!row.Start || !row.Start.includes('/')) return;

                        try {
                            const childNet = this.parseNetwork(row.Start);

                            // Check if child is strictly inside the old parent range
                            if (childNet.numericStart >= oldNetwork.numericStart &&
                                childNet.numericEnd <= oldNetwork.numericEnd &&
                                childNet.prefix > oldNetwork.prefix) {
                                childRows.push({ idx, childNet, row });
                            }
                        } catch (e) {
                            // Skip invalid CIDRs
                        }
                    });

                    if (childRows.length === 0) return;

                    // Ask user for confirmation
                    const confirmMsg = `Chcete automaticky upravit ${childRows.length} podrizených IP adres?\n\n` +
                        `Zmena: ${this.numericToIP(oldNetwork.numericStart)} → ${this.numericToIP(newNetwork.numericStart)}\n` +
                        `Posun: ${offset >= 0 ? '+' : ''}${offset} adres`;

                    if (!confirm(confirmMsg)) return;

                    // Apply offset to all child rows
                    for (const { idx, childNet, row } of childRows) {
                        const newChildStart = childNet.numericStart + offset;
                        const newChildEnd = childNet.numericEnd + offset;

                        // Update Start
                        row.Start = `${this.numericToIP(newChildStart)}/${childNet.prefix}`;

                        // Recalculate Address space and Available addresses
                        row['Address space'] = `${this.numericToIP(newChildStart)} - ${this.numericToIP(newChildEnd)}`;
                        row['Available addresses'] = this.calculateAvailableIPs(childNet.prefix).toString();

                        // Update Subnet name if it contains the IP
                        const purpose = row['Subnet purpose'];
                        const azureSpecial = ['AzureBastionSubnet', 'GatewaySubnet', 'RouterServerSubnet', 'AzureFirewallSubnet', 'AzureFirewallManagementSubnet'];
                        if (purpose && !azureSpecial.includes(purpose)) {
                            row['Subnet name'] = this.generateSubnetName(row, this.subnetNamingPattern, idx);
                        }
                    }

                    this.calculateGroups();
                },

                onPurposeEdit(index) {
                    this.stopEdit();
                    const row = this.csvData[index];
                    const purpose = row['Subnet purpose'];
                    const start = row.Start;

                    const azureSpecial = ['AzureBastionSubnet', 'GatewaySubnet', 'RouterServerSubnet', 'AzureFirewallSubnet', 'AzureFirewallManagementSubnet'];

                    if (purpose && start && start.includes('/') && !azureSpecial.includes(purpose)) {
                        row['Subnet name'] = this.generateSubnetName(row, this.subnetNamingPattern, index);
                    } else if (!purpose || azureSpecial.includes(purpose)) {
                        row['Subnet name'] = purpose || '';
                    }

                    this.validateAll();
                },

                recalculateRow(index) {
                    const row = this.csvData[index];
                    const start = row.Start;

                    if (!start || !start.includes('/')) return;

                    try {
                        const net = this.parseNetwork(start);
                        row['Address space'] = `${this.numericToIP(net.numericStart)} - ${this.numericToIP(net.numericEnd)}`;
                        row['Available addresses'] = this.calculateAvailableIPs(net.prefix).toString();

                        // Update name if purpose exists
                        const purpose = row['Subnet purpose'];
                        const azureSpecial = ['AzureBastionSubnet', 'GatewaySubnet', 'RouterServerSubnet', 'AzureFirewallSubnet', 'AzureFirewallManagementSubnet'];
                        if (purpose && !azureSpecial.includes(purpose)) {
                            row['Subnet name'] = this.generateSubnetName(row, this.subnetNamingPattern, index);
                        }
                    } catch (e) {
                        // Invalid CIDR - leave as is
                    }
                },

                recalculateAll() {
                    this.csvData.forEach((row, index) => {
                        this.recalculateRow(index);
                    });
                    this.validateAll();
                    this.detectGaps();
                },

                selectRow(index) {
                    this.selectedRowIndex = index;
                },

                scrollToRow(rowNum) {
                    const element = document.getElementById(`row-${rowNum}`);
                    if (element) {
                        element.scrollIntoView({ behavior: 'smooth', block: 'center' });
                        element.style.boxShadow = '0 0 20px rgba(239, 68, 68, 0.6)';
                        setTimeout(() => {
                            element.style.boxShadow = '';
                        }, 2000);
                    }
                },

                addSubnetAfter(index) {
                    this.selectedRowIndex = index;
                    this.showAddModal = true;

                    const currentRow = this.csvData[index];
                    let nextIP = '';

                    if (currentRow.Start && currentRow.Start.includes('/')) {
                        try {
                            const currentNet = this.parseNetwork(currentRow.Start);
                            nextIP = this.numericToIP(currentNet.numericEnd + 1);
                        } catch (e) {
                            nextIP = '';
                        }
                    }

                    this.newSubnet = {
                        suggested: nextIP ? `${nextIP}/24` : '',
                        prefix: 24,
                        start: '',
                        addressSpace: '',
                        type: currentRow['Subnet type'] || '',
                        purpose: '',
                        name: '',
                        available: '',
                        comments: ''
                    };

                    if (nextIP) {
                        this.updateNewSubnet();
                    }
                },

                duplicateRow(index) {
                    const original = this.csvData[index];
                    const newRow = { ...original };
                    this.csvData.splice(index + 1, 0, newRow);
                    this.calculateGroups();
                },

                deleteRow(index) {
                    const row = this.csvData[index];
                    const start = row.Start;

                    // Check if this row has child rows within its IP range
                    let childIndices = [];
                    if (start && start.includes('/')) {
                        try {
                            const parentNet = this.parseNetwork(start);

                            // Find all rows whose IP falls strictly within this range
                            this.csvData.forEach((r, idx) => {
                                if (idx === index) return;
                                if (!r.Start || !r.Start.includes('/')) return;

                                try {
                                    const childNet = this.parseNetwork(r.Start);
                                    // Check if child is strictly inside parent range
                                    if (childNet.numericStart >= parentNet.numericStart &&
                                        childNet.numericEnd <= parentNet.numericEnd &&
                                        childNet.prefix > parentNet.prefix) {
                                        childIndices.push(idx);
                                    }
                                } catch (e) {
                                    // Skip invalid CIDRs
                                }
                            });
                        } catch (e) {
                            // Invalid parent CIDR, no children to find
                        }
                    }

                    if (childIndices.length > 0) {
                        // Has children - ask what to do
                        const level = this.getRowLevel(row);
                        const levelNames = {
                            'region': 'Region',
                            'network-segment': 'Network segment',
                            'management-group': 'Management Group',
                            'subscription': 'Subscription',
                            'vnet': 'VNet',
                            'subnet': 'Subnet',
                            'free-space': 'Free space'
                        };
                        const levelName = levelNames[level] || 'Radek';

                        const choice = confirm(
                            `${levelName} "${start}" obsahuje ${childIndices.length} podrizených radku.\n\n` +
                            `Klikni OK pro smazani VSECH (${childIndices.length + 1} radku)\n` +
                            `Klikni Zrusit pro smazani pouze tohoto radku`
                        );

                        if (choice) {
                            // Delete all - sort indices descending to maintain correct positions
                            const allIndices = [index, ...childIndices].sort((a, b) => b - a);
                            for (const idx of allIndices) {
                                this.csvData.splice(idx, 1);
                            }
                        } else {
                            // Delete only parent
                            this.csvData.splice(index, 1);
                        }
                    } else {
                        // No children - simple delete with confirmation
                        if (!confirm(`Opravdu chcete smazat radek ${index + 2}?`)) return;
                        this.csvData.splice(index, 1);
                    }

                    this.calculateGroups();
                    this.validateAll();
                    this.detectGaps();
                },

                moveRowUp(index) {
                    if (index <= 0) return;
                    const row = this.csvData.splice(index, 1)[0];
                    this.csvData.splice(index - 1, 0, row);
                    this.selectedRowIndex = index - 1;
                    this.calculateGroups();
                    this.validateAll();
                    this.detectGaps();
                },

                moveRowDown(index) {
                    if (index >= this.csvData.length - 1) return;
                    const row = this.csvData.splice(index, 1)[0];
                    this.csvData.splice(index + 1, 0, row);
                    this.selectedRowIndex = index + 1;
                    this.calculateGroups();
                    this.validateAll();
                    this.detectGaps();
                },

                updateNewSubnetFromSuggested() {
                    const parts = this.newSubnet.suggested.split('/');
                    if (parts.length === 2) {
                        const prefix = parseInt(parts[1]);
                        if (!isNaN(prefix) && prefix >= 16 && prefix <= 30) {
                            this.newSubnet.prefix = prefix;
                        }
                    }
                    this.updateNewSubnet();
                },

                updateNewSubnet() {
                    const startIP = this.newSubnet.suggested.split('/')[0];
                    const prefix = parseInt(this.newSubnet.prefix);

                    if (!startIP || !this.isValidIP(startIP)) {
                        this.newSubnet.start = '';
                        this.newSubnet.addressSpace = '';
                        this.newSubnet.available = '';
                        return;
                    }

                    try {
                        const net = this.parseNetwork(`${startIP}/${prefix}`);

                        this.newSubnet.start = `${startIP}/${prefix}`;
                        this.newSubnet.addressSpace = `${startIP} - ${this.numericToIP(net.numericEnd)}`;
                        this.newSubnet.available = this.calculateAvailableIPs(prefix).toString();

                        this.updateSubnetName();
                    } catch (e) {
                        // Invalid input
                    }
                },

                updateSubnetName() {
                    const currentName = (this.newSubnet.name || '').toLowerCase();
                    if (this.newSubnet.purpose && this.newSubnet.purpose.toLowerCase() !== 'free space') {
                        // Build a temporary row object for name generation
                        const templateRow = this.csvData[this.selectedRowIndex] || {};
                        const tempRow = {
                            'Region': templateRow.Region || '',
                            'Network segment': templateRow['Network segment'] || '',
                            'Management Group': templateRow['Management Group'] || '',
                            'Subscription': templateRow.Subscription || '',
                            'VNet name': templateRow['VNet name'] || '',
                            'Subnet purpose': this.newSubnet.purpose,
                            'Start': this.newSubnet.start
                        };
                        this.newSubnet.name = this.generateSubnetName(tempRow, this.subnetNamingPattern);
                    } else if (!currentName.includes('free space')) {
                        this.newSubnet.name = '';
                    }
                },

                confirmAddSubnet() {
                    const templateRow = this.csvData[this.selectedRowIndex];

                    const newRow = {
                        'Region': templateRow.Region || '',
                        'Network segment': templateRow['Network segment'] || '',
                        'Management Group': templateRow['Management Group'] || '',
                        'Subscription': templateRow.Subscription || '',
                        'VNet name': templateRow['VNet name'] || '',
                        'Subnet type': this.newSubnet.type,
                        'Start': this.newSubnet.start,
                        'Address space': this.newSubnet.addressSpace,
                        'Subnet purpose': this.newSubnet.purpose,
                        'Subnet name': this.newSubnet.name,
                        'Available addresses': this.newSubnet.available,
                        'Comments': this.newSubnet.comments
                    };

                    this.csvData.splice(this.selectedRowIndex + 1, 0, newRow);
                    this.showAddModal = false;
                    this.calculateGroups();
                    this.validateAll();
                    this.detectGaps();
                },

                getRowClass(row, index) {
                    const classes = [];

                    // Check for errors/warnings
                    const rowNum = index + 2;
                    if (this.errorRows.has(rowNum)) {
                        classes.push('row-error');
                    } else if (this.warningRows.has(rowNum)) {
                        classes.push('row-warning');
                    }

                    return classes.join(' ');
                },

                // Get border classes for a cell based on hierarchy grouping
                // Columns: 0=Region, 1=Segment, 2=MG, 3=Subscription, 4=VNet, 5-12=rest
                getCellBorderClass(row, colIndex, index) {
                    const classes = [];

                    // Find which groups this row belongs to
                    const segmentGroup = this.segmentGroups.find(g => index >= g.start && index <= g.end);
                    const mgGroup = this.mgGroups.find(g => index >= g.start && index <= g.end);
                    const subscriptionGroup = this.subscriptionGroups.find(g => index >= g.start && index <= g.end);
                    const vnetGroup = this.vnetGroups.find(g => index >= g.start && index <= g.end);

                    // Network Segment border - starts from column 1
                    if (segmentGroup && colIndex >= 1) {
                        const hasInnerBorder = (mgGroup && colIndex >= 2) || (subscriptionGroup && colIndex >= 3) || (vnetGroup && colIndex >= 4);

                        if (colIndex === 1) {
                            classes.push('seg-border-left');
                            if (index === segmentGroup.start) classes.push('seg-border-top');
                            if (index === segmentGroup.end) classes.push('seg-border-bottom');
                        }

                        if (!hasInnerBorder) {
                            if (index === segmentGroup.start && colIndex > 1) classes.push('seg-border-top');
                            if (index === segmentGroup.end && colIndex > 1) classes.push('seg-border-bottom');
                            if (colIndex === 12) classes.push('seg-border-right');
                        }
                    }

                    // Management Group border - starts from column 2
                    if (mgGroup && colIndex >= 2) {
                        const hasInnerBorder = (subscriptionGroup && colIndex >= 3) || (vnetGroup && colIndex >= 4);

                        if (colIndex === 2) {
                            classes.push('mg-border-left');
                            if (index === mgGroup.start) classes.push('mg-border-top');
                            if (index === mgGroup.end) classes.push('mg-border-bottom');
                        }

                        if (!hasInnerBorder) {
                            if (index === mgGroup.start && colIndex > 2) classes.push('mg-border-top');
                            if (index === mgGroup.end && colIndex > 2) classes.push('mg-border-bottom');
                            if (colIndex === 12) classes.push('mg-border-right');
                        }
                    }

                    // Subscription border - starts from column 3
                    if (subscriptionGroup && colIndex >= 3) {
                        const hasInnerBorder = vnetGroup && colIndex >= 4;

                        if (colIndex === 3) {
                            classes.push('sub-border-left');
                            if (index === subscriptionGroup.start) classes.push('sub-border-top');
                            if (index === subscriptionGroup.end) classes.push('sub-border-bottom');
                        }

                        if (!hasInnerBorder) {
                            if (index === subscriptionGroup.start && colIndex > 3) classes.push('sub-border-top');
                            if (index === subscriptionGroup.end && colIndex > 3) classes.push('sub-border-bottom');
                            if (colIndex === 12) classes.push('sub-border-right');
                        }
                    }

                    // VNet border - starts from column 4
                    if (vnetGroup && colIndex >= 4) {
                        if (colIndex === 4) classes.push('vnet-border-left');
                        if (index === vnetGroup.start) classes.push('vnet-border-top');
                        if (index === vnetGroup.end) classes.push('vnet-border-bottom');
                        if (colIndex === 12) classes.push('vnet-border-right');
                    }

                    return classes.join(' ');
                },

                // Get cell class based on column position and row level
                getCellClass(row, colIndex, index) {
                    const rowNum = index + 2;

                    // Error/warning takes priority
                    if (this.errorRows.has(rowNum)) {
                        return 'cell-error';
                    }
                    if (this.warningRows.has(rowNum)) {
                        return 'cell-warning';
                    }

                    // Determine the first filled column index (hierarchy columns 0-4)
                    // 0=Region, 1=Segment, 2=MG, 3=Subscription, 4=VNet
                    const hasRegion = row.Region && row.Region.trim();
                    const hasSegment = row['Network segment'] && row['Network segment'].trim();
                    const hasMG = row['Management Group'] && row['Management Group'].trim();
                    const hasSubscription = row.Subscription && row.Subscription.trim();
                    const hasVNet = row['VNet name'] && row['VNet name'].trim();

                    let firstFilledCol = -1;
                    if (hasRegion) firstFilledCol = 0;
                    else if (hasSegment) firstFilledCol = 1;
                    else if (hasMG) firstFilledCol = 2;
                    else if (hasSubscription) firstFilledCol = 3;
                    else if (hasVNet) firstFilledCol = 4;
                    else firstFilledCol = 5; // Start from Type/Start columns

                    // If this column is before the first filled, keep it white
                    if (colIndex < firstFilledCol) {
                        return 'cell-white';
                    }

                    // Get level and return appropriate color class
                    const level = this.getRowLevel(row);
                    const colorMap = {
                        'region': 'cell-region',
                        'network-segment': 'cell-segment',
                        'management-group': 'cell-mg',
                        'subscription': 'cell-subscription',
                        'vnet': 'cell-vnet',
                        'subnet': 'cell-subnet',
                        'free-space': 'cell-free-space'
                    };
                    return colorMap[level] || 'cell-white';
                },

                exportCSV() {
                    const headers = [
                        'Region',
                        'Network segment',
                        'Management Group',
                        'Subscription',
                        'VNet name',
                        'Subnet type',
                        'Start',
                        'Address space',
                        'Subnet purpose',
                        'Subnet name',
                        'Available addresses',
                        'Comments'
                    ];
                    let csv = headers.join(';') + '\n';

                    this.csvData.forEach(row => {
                        csv += headers.map(h => row[h] || '').join(';') + '\n';
                    });

                    const blob = new Blob(['\uFEFF' + csv], { type: 'text/csv;charset=utf-8;' });
                    const link = document.createElement('a');
                    link.href = URL.createObjectURL(blob);
                    link.download = 'IP_Plan_Updated.csv';
                    link.click();
                },

                reset() {
                    if (confirm('Opravdu chcete zrusit vsechny zmeny a nacist novy soubor?')) {
                        this.csvData = [];
                        this.errors = [];
                        this.warnings = [];
                        this.gaps = [];
                        this.errorRows = new Set();
                        this.warningRows = new Set();
                        this.editingCell = null;
                        this.selectedRowIndex = -1;
                        this.lastValidation = '';
                        this.sidePanelOpen = false;
                        this.segmentGroups = [];
                        this.mgGroups = [];
                        this.subscriptionGroups = [];
                        this.vnetGroups = [];
                    }
                },

                createNewPlan() {
                    // Create empty row template
                    const emptyRow = {
                        'Region': '',
                        'Network segment': '',
                        'Management Group': '',
                        'Subscription': '',
                        'VNet name': '',
                        'Subnet type': '',
                        'Start': '',
                        'Address space': '',
                        'Subnet purpose': '',
                        'Subnet name': '',
                        'Available addresses': '',
                        'Comments': ''
                    };

                    // Create a few starter rows
                    this.csvData = [
                        { ...emptyRow, 'Region': 'West Europe (WE)' },
                        { ...emptyRow },
                        { ...emptyRow },
                        { ...emptyRow },
                        { ...emptyRow }
                    ];

                    this.errors = [];
                    this.warnings = [];
                    this.gaps = [];
                    this.errorRows = new Set();
                    this.warningRows = new Set();
                    this.calculateGroups();
                },

                // IP Utilities
                parseNetwork(cidr) {
                    const [ip, prefix] = cidr.split('/');
                    const prefixNum = parseInt(prefix);

                    if (!this.isValidIP(ip) || isNaN(prefixNum) || prefixNum < 0 || prefixNum > 32) {
                        throw new Error('Invalid CIDR');
                    }

                    const ipParts = ip.split('.').map(p => parseInt(p));

                    const numericIP = (ipParts[0] << 24) + (ipParts[1] << 16) + (ipParts[2] << 8) + ipParts[3];
                    const mask = prefixNum === 0 ? 0 : (0xFFFFFFFF << (32 - prefixNum)) >>> 0;
                    const networkStart = (numericIP & mask) >>> 0;
                    const networkEnd = (networkStart | (~mask >>> 0)) >>> 0;

                    return {
                        ip,
                        prefix: prefixNum,
                        numericStart: networkStart,
                        numericEnd: networkEnd,
                        mask
                };
            },

                isValidIP(ip) {
                    const parts = ip.split('.');
                    if (parts.length !== 4) return false;
                    return parts.every(p => {
                        const num = parseInt(p);
                        return !isNaN(num) && num >= 0 && num <= 255 && p === num.toString();
                    });
                },

                numericToIP(num) {
                    return [
                        (num >>> 24) & 0xFF,
                        (num >>> 16) & 0xFF,
                        (num >>> 8) & 0xFF,
                        num & 0xFF
                    ].join('.');
                },

                networksOverlap(net1, net2) {
                    return (net1.numericStart <= net2.numericEnd && net1.numericEnd >= net2.numericStart);
                },

                isSubnetOf(child, parent) {
                    return child.numericStart >= parent.numericStart &&
                           child.numericEnd <= parent.numericEnd &&
                           child.prefix > parent.prefix;
                },

                calculateAvailableIPs(prefix) {
                    const total = Math.pow(2, 32 - prefix);
                    // Azure reserves 5 IPs per subnet
                    return Math.max(0, total - 5);
                },

                suggestPrefix(size) {
                    for (let prefix = 30; prefix >= 16; prefix--) {
                        const available = Math.pow(2, 32 - prefix);
                        if (available >= size) return prefix;
                    }
                    return 24;
                },

                formatNumber(num) {
                    return new Intl.NumberFormat('cs-CZ').format(num);
                },

                // Extract region abbreviation from text like "West Europe (WE)" -> "we"
                extractRegionAbbr(regionText) {
                    if (!regionText) return '';
                    // Try to find abbreviation in parentheses
                    const match = regionText.match(/\(([^)]+)\)/);
                    if (match) {
                        return match[1].toLowerCase();
                    }
                    // Fallback: take first letters of each word
                    return regionText.split(/\s+/).map(w => w[0]).join('').toLowerCase();
                },

                // Find region for a row - check row itself, then parent rows, then ask user
                findRegionForRow(row, rowIndex) {
                    // 1. Check if row has Region
                    if (row.Region && row.Region.trim()) {
                        return row.Region.trim();
                    }

                    // 2. Try to find parent row with Region based on IP containment
                    if (row.Start && row.Start.includes('/')) {
                        try {
                            const rowNet = this.parseNetwork(row.Start);

                            // Search all rows for a parent with Region
                            for (let i = 0; i < this.csvData.length; i++) {
                                const candidate = this.csvData[i];
                                if (!candidate.Region || !candidate.Region.trim()) continue;
                                if (!candidate.Start || !candidate.Start.includes('/')) continue;

                                try {
                                    const candNet = this.parseNetwork(candidate.Start);
                                    // Check if current row is inside this candidate's range
                                    if (rowNet.numericStart >= candNet.numericStart &&
                                        rowNet.numericEnd <= candNet.numericEnd) {
                                        return candidate.Region.trim();
                                    }
                                } catch (e) {
                                    // Skip invalid
                                }
                            }
                        } catch (e) {
                            // Invalid row IP
                        }
                    }

                    // 3. Check first rows (often Region is in row 1-2)
                    for (let i = 0; i < Math.min(5, this.csvData.length); i++) {
                        if (this.csvData[i].Region && this.csvData[i].Region.trim()) {
                            return this.csvData[i].Region.trim();
                        }
                    }

                    // 4. Not found - return empty, will prompt user in applyNamingPatternToAll
                    return '';
                },

                // Generate subnet name based on pattern
                generateSubnetName(row, pattern, rowIndex = -1) {
                    if (!pattern) return '';

                    const start = row.Start || '';
                    const startFormatted = start.replace('/', '-');

                    // Find region - check row, then parents, then first rows
                    const region = rowIndex >= 0 ? this.findRegionForRow(row, rowIndex) : (row.Region || '');

                    let name = pattern;
                    name = name.replace(/\{purpose\}/gi, row['Subnet purpose'] || '');
                    name = name.replace(/\{region\}/gi, this.extractRegionAbbr(region));
                    name = name.replace(/\{start\}/gi, startFormatted);
                    name = name.replace(/\{vnet\}/gi, row['VNet name'] || '');
                    name = name.replace(/\{subscription\}/gi, row.Subscription || '');
                    name = name.replace(/\{mg\}/gi, row['Management Group'] || '');
                    name = name.replace(/\{segment\}/gi, row['Network segment'] || '');

                    // Clean up multiple dashes and trim
                    name = name.replace(/-+/g, '-').replace(/^-|-$/g, '');

                    return name;
                },

                // Apply naming pattern to all subnet rows
                applyNamingPatternToAll() {
                    const azureSpecial = ['AzureBastionSubnet', 'GatewaySubnet', 'RouterServerSubnet', 'AzureFirewallSubnet', 'AzureFirewallManagementSubnet'];
                    let updated = 0;
                    let missingRegion = false;
                    let userRegion = null;

                    // Check if pattern uses region
                    const usesRegion = this.subnetNamingPattern.includes('{region}');

                    // First pass: check if any row is missing region
                    if (usesRegion) {
                        for (let i = 0; i < this.csvData.length; i++) {
                            const row = this.csvData[i];
                            const level = this.getRowLevel(row);
                            const purpose = row['Subnet purpose'];

                            if (level === 'subnet' && purpose && !azureSpecial.includes(purpose)) {
                                const region = this.findRegionForRow(row, i);
                                if (!region) {
                                    missingRegion = true;
                                    break;
                                }
                            }
                        }

                        // Ask user for region if missing
                        if (missingRegion) {
                            userRegion = prompt('Nekterym radkum chybi Region. Zadej zkratku regionu (napr. "we", "gwc"):');
                            if (userRegion === null) {
                                return; // User cancelled
                            }
                            userRegion = userRegion.trim().toLowerCase();
                        }
                    }

                    this.csvData.forEach((row, index) => {
                        const level = this.getRowLevel(row);
                        const purpose = row['Subnet purpose'];

                        // Only update actual subnets with purpose (not free space, not Azure special)
                        if (level === 'subnet' && purpose && !azureSpecial.includes(purpose)) {
                            // Use found region or user-provided fallback
                            let region = this.findRegionForRow(row, index);
                            if (!region && userRegion) {
                                region = userRegion;
                            }

                            // Temporarily set region for name generation
                            const originalRegion = row.Region;
                            if (!row.Region && region) {
                                row._tempRegion = region;
                            }

                            const newName = this.generateSubnetNameWithRegion(row, this.subnetNamingPattern, index, region);
                            if (newName && row['Subnet name'] !== newName) {
                                row['Subnet name'] = newName;
                                updated++;
                            }

                            delete row._tempRegion;
                        }
                    });

                    this.showNamingModal = false;
                    if (updated > 0) {
                        this.autoFixNotice = `Aktualizovano ${updated} nazvu subnetu.`;
                        setTimeout(() => { this.autoFixNotice = ''; }, 3000);
                    }
                },

                // Generate subnet name with explicit region override
                generateSubnetNameWithRegion(row, pattern, rowIndex, regionOverride) {
                    if (!pattern) return '';

                    const start = row.Start || '';
                    const startFormatted = start.replace('/', '-');

                    // Use override or find region
                    let region = regionOverride || this.findRegionForRow(row, rowIndex);

                    let name = pattern;
                    name = name.replace(/\{purpose\}/gi, row['Subnet purpose'] || '');
                    name = name.replace(/\{region\}/gi, this.extractRegionAbbr(region) || region);
                    name = name.replace(/\{start\}/gi, startFormatted);
                    name = name.replace(/\{vnet\}/gi, row['VNet name'] || '');
                    name = name.replace(/\{subscription\}/gi, row.Subscription || '');
                    name = name.replace(/\{mg\}/gi, row['Management Group'] || '');
                    name = name.replace(/\{segment\}/gi, row['Network segment'] || '');

                    // Clean up multiple dashes and trim
                    name = name.replace(/-+/g, '-').replace(/^-|-$/g, '');

                    return name;
                }
            }
        }).mount('#app');
    </script>
</body>
</html>
